/* globals window, RTCSessionDescription */

import bowser from 'bowser';
import { some } from 'lodash';
import sdpTransform from 'sdp-transform';

import CallDiagnosticUtil from '../../../scripts/modules/call-diagnostic/CallDiagnosticUtil';
import CallDiagnosticConstants from '../../../scripts/modules/call-diagnostic/CallDiagnosticConstants';
import { console, calls } from '../../constants/config';

import MeetingConfig from '../meetings/meeting-config';
import * as MeetingConstants from '../meetings/meeting-constants';
import FeatureStore from '../features/FeatureStore.js';
import FeatureConfig from '../../constants/FeatureToggle.js';

import UserUtil from '../../utils/UserUtil';
import MediaConstants from '../../utils/MediaConstants';

import MeetingAdapter from '../../../scripts/modules/meetings/meeting-adapter';

const PC = {};

// flag for a workaround if present true
const extmapFix = () => !FeatureStore.get(FeatureConfig.DEVELOPER, FeatureConfig.EXTMAP_FIX_DISABLE);
const forceAudioCalls = () => !FeatureStore.get(FeatureConfig.DEVELOPER, FeatureConfig.WEB_FORCE_AUDIO_CALLS);
const edonusHack = () => FeatureStore.get(FeatureConfig.DEVELOPER, FeatureConfig.WEB_EDONUS_HACK);

const containsNonUsers = (locus) =>
    some(locus.participants, UserUtil.isTestUser);

/*
SDP has n number of lines with rtpmap:<someNumber> H264 which is the payload mapping to the H264 codec that
linus cares about SDP also has n number of a=fmtp lines with various profile ids, packetization modes, and
a mapping payload type as well We have to find all the rtp mapped payloads, match them against all the payload
types in the (a) lines of the sdp and match them against the H264 codec profile id that Linus accepts (42e01f),
and find which a line has the correct payload, and sets it's packetization mode, so that we can tack a
;max-fs=8160 onto that line so Linus believes we can receive 1080p for content shares, and we won't degrade
other clients experience from a high resolution stream
TODO we need to add this function to testing in the media module being developed on ROAP
TODO move the regex and other magic numbers here to the media module constants
*/
const setMaxFs = (sdp) => {
    let replaceSdp = sdp;
    const payloadTypes = sdp.match(/\na=fmtp:(\d+).*level-asymmetry-allowed=1.*/g);
    if (payloadTypes) {
        payloadTypes.forEach((payload) => {
            replaceSdp = replaceSdp.replace(payload, `${payload};max-fs=8160`);
        });
    }
    return replaceSdp;
};

const checkH264Support = (sdp) => {
    const videoPresent = sdp.match(/\nm=video.*/g);
    const h264Present = sdp.match(/\na=rtpmap:\d+\sH264.*/g);

    if (videoPresent) {
        return !!h264Present;
    }
    return true;
};

const validateSdp = (sdp) => {
    // https://github.com/clux/sdp-transform
    const parsedSdp = sdpTransform.parse(sdp);

    parsedSdp.media.forEach((mediaLine) => {
        if (mediaLine.candidates && mediaLine.candidates.length === 0) {
            console.error('iceCandidate: Ice candadate never completed');
            return false;
        }
        if ([9, 0].includes(mediaLine.port)) {
            console.error('iceCandidate: Found invalid port number for the ice candidate');
            return false;
        }
        if (!mediaLine.icePwd || !mediaLine.iceUfrag) {
            console.error('iceCandidate: ice ufrag and password not found');
            return false;
        }
        return true;
    });
};


const addBasicCallMetrics = (locus, device, report) => {
    // TODO: Rather then manuplating the object we can just return new value
    report.containsNonUsers = containsNonUsers(locus);
    report.deviceUrl = device;
    report.isGroup = !locus.oneOnOne;
    report.isNonStandard = (process.env.NODE_ENV === 'development');
    report.locusId = locus.id;
    report.locusTimestamp = locus.fullState.lastActive;
    report.participantId = locus.self.id;
    report.requestTimestamp = (new Date()).toISOString();
    report.isZtm = locus.isZtm;
    if (locus.usingResource && locus.usingResourceType) {
        report.resourceType = locus.usingResourceType;
        // if it's a UC type, then it's a url so parse out id
        report.resourceId = locus.usingResourceType === MeetingConstants.devices.types.UC ? locus.usingResource.split('/').pop() : locus.usingResource;
    }
};

const insertBandwidthLimit = (sdpLines, index) => {
    let limit;
    if (sdpLines[index].search('audio') !== -1) {
        limit = MeetingConfig.meetings.audioBandwidthLimit;
    }
    else {
        limit = MeetingConfig.meetings.videoBandwidthLimit;
    }
    sdpLines.splice(index + 1, 0, `b=TIAS:${limit}`);
    return sdpLines;
};

const limitBandwidth = (offerSdp) => {
    let sdp = offerSdp;
    let sdpLines = sdp.split('\r\n');

    for (let i = 0; i < sdpLines.length; i += 1) {
        if (sdpLines[i].search('m=') !== -1) {
            sdpLines = insertBandwidthLimit(sdpLines, i);
        }
    }
    sdp = sdpLines.join('\r\n');
    return sdp;
};

PC.iceCandidate = (pc) => new Promise(((resolve) => {
    // TODO: we dont need timeout as we can check the api state and validate.
    const timeout = setTimeout(() => {
        pc.sdp = limitBandwidth(pc.localDescription.sdp);
        pc.sdp = setMaxFs(pc.sdp);
        if (extmapFix()) {
            pc.sdp = pc.sdp.replace(/\na=extmap.*/g, '');
        }

        // TODO: Adding this as a precation if the ice gathering doesnt happen with in 3 sec
        // We will wait for another 3 sec to respond
        if (!validateSdp(pc.sdp)) {
            setTimeout(() => {
                resolve(pc);
            }, MeetingConfig.meetings.retryTimeout);
        }
        else {
            resolve(pc);
        }
    }, MeetingConfig.meetings.iceTimeout);

    pc.onicecandidate = (evt) => {
        if (!evt.candidate && !pc.sdp) {
            // pc.sdp = pc.localDescription.sdp
            // TODO: CHECK why do we need this

            pc.sdp = limitBandwidth(pc.localDescription.sdp);
            pc.sdp = setMaxFs(pc.sdp);
            if (extmapFix()) {
                pc.sdp = pc.sdp.replace(/\na=extmap.*/g, '');
            }
            if (evt.candidate === null) {
                validateSdp(pc.sdp);
                clearTimeout(timeout);
                resolve(pc);
            }
        }
    };
}));

// TODO: WIP there is a issue with firefox
PC.replaceTrack = (pc, track) => {
    try {
        const senders = pc.getSenders();
        if (senders.length > 0) {
            senders.forEach((sender) => {
                if (sender.track && sender.track.kind === track.kind) {
                    sender.replaceTrack(track);
                }
            });
        }
    }
    catch (e) {
        console.error('replaceTrack: Error while replacing Tracks ', e);
    }
};

/*
* adding streams to peerConnection
* @param {Object} peerconnetion
* @param {Object} stream
*/

PC.addStream = (pc, stream) => {
    console.info('addStream: adding streams to peerconnection');

    try {
        if (stream && !bowser.msedge) {
            const tracksPresent = pc.getSenders && pc.getSenders().find((sender) => sender.track != null);
            if (tracksPresent) {
                stream.getTracks().forEach((track) => {
                    PC.replaceTrack(pc, track);
                });
                return;
            }
            stream.getTracks().forEach((track) => {
                pc.addTrack(track, stream);
            });
            // // TODO : may come back disable addTracks for chrome they are moving back to addStream
            // // https://bugs.chromium.org/p/chromium/issues/detail?id=764414
            // // https://bugs.chromium.org/p/chromium/issues/detail?id=738918#c7
            //   pc.addStream(stream);
        }
        else if (bowser.msedge) {
            pc.addStream(stream);
        }
        else {
            console.error('addStream: No streams to add');
        }
    }
    catch (e) {
        console.error('addStream: Error while adding Stream ', e);
    }
};


// TODO : This is only used by screen share so assumeing all the stream
// in pc belongs to content
// So we are not passing sender of the stream to remove but just removing all the tracks
PC.removeStream = (pc, stream) => {
    console.info('removeStream: removing streams from peerconnection');
    try {
        const senders = pc && pc.getSenders();
        if (stream) {
            // TODO : disable removeTracks for chrome they are moving back to addStream
            // https://bugs.chromium.org/p/chromium/issues/detail?id=764414
            // https://bugs.chromium.org/p/chromium/issues/detail?id=738918#c7
            if (pc.removeTrack && senders && senders.length > 0) {
                senders.forEach((sender) => {
                    pc.removeTrack(sender);
                });
            }
            else {
                pc.removeStream(stream);
            }
        }
        else {
            console.error('removeStream: No streams to remove');
        }
    }
    catch (e) {
        console.error('removeStream: Error while removing Stream ', e);
    }
};

/*
* setting the remote description
* @param {Object} MainPeerconnetion
* @param {String} OFFER/ANSWER
* @sdp {String} SDP
* @param {Object} ScreenPeerconnetion
*/

PC.setRemoteSessionDetails = (pc, typeStr, remoteSdp, identifiers) => {
    const { screenPc } = pc;
    console.info(`Setting the remote description type: ${typeStr}State: ${pc.signalingState}`);
    const promiseSdp = [];
    let sdp = remoteSdp;
    if (extmapFix()) {
        sdp = sdp.replace(/\na=extmap.*/g, '');
    }
    const mlines = sdp.split('m=');
    if (mlines.length === 4 && screenPc) {
        sdp = `${mlines[0]}m=${mlines[1]}m=${mlines[2]}`;
        const contentSdp = `${mlines[0]}m=${mlines[3]}`;
        promiseSdp.push(screenPc.setRemoteDescription(new window.RTCSessionDescription({
            type: typeStr,
            sdp: contentSdp
        })));
    }

    // making sure that the remoteDescription is only set when there is a answer for offer
    // or there is a offer from the server
    if (pc.signalingState === 'have-local-offer' || (pc.signalingState === 'stable' && typeStr === 'offer')) {
        promiseSdp.push(pc.setRemoteDescription(new window.RTCSessionDescription({
            type: typeStr,
            sdp
        })));
    }
    return Promise.all(promiseSdp)
        .then(() => {
            CallDiagnosticUtil.sendCallDiagnosticEvent(
                CallDiagnosticConstants.eventType.CLIENT_MEDIA_ENGINE_REMOTE_SDP_RECEIVED, identifiers
            );
        })
        .catch((e) => {
            console.error('Error setting the remoteDescription', e);
            CallDiagnosticUtil.sendCallDiagnosticEvent(
                CallDiagnosticConstants.eventType.CLIENT_MEDIA_ENGINE_REMOTE_SDP_RECEIVED,
                identifiers, {
                    canProceed: false,
                    errors: [CallDiagnosticUtil.createErrorPayloadWithErrorCode(2001, true,
                        CallDiagnosticConstants.error.name.MEDIA_ENGINE, 'missing remoteSdp')]
                }
            );
            return Promise.reject(e);
        });
};

PC.createOffer = (params, identifiers) => {
    let pc;
    try {
        if (!params.sharing || bowser.firefox) {
            pc = params.peerConnection || new window.RTCPeerConnection(bowser.firefox
                ? calls.rtcConfigurationFirefox : calls.rtcConfiguration);
        }
        else {
            pc = new window.RTCPeerConnection(bowser.firefox ? calls.rtcConfigurationFirefox : calls.rtcConfiguration);
        }
        PC.addStream(pc, params.stream);
    }
    catch (e) {
        console.error('PCUtils: `createOffer` error while initiating call', e);
    }

    const sdpConstraints = {
        offerToReceiveAudio: params.offerToReceiveAudio,
        offerToReceiveVideo: forceAudioCalls() ? params.offerToReceiveVideo : false
    };

    if (pc && pc.createOffer) {
        return pc.createOffer(sdpConstraints)
            .then((sdp) => {
                CallDiagnosticUtil.sendCallDiagnosticEvent(
                    CallDiagnosticConstants.eventType.CLIENT_MEDIA_ENGINE_LOCAL_SDP_GENERATED, identifiers
                );
                return pc.setLocalDescription(sdp)
                    .then(() => Promise.resolve(PC.iceCandidate(pc)));
            })
            .catch((error) => {
                const errorPayload = CallDiagnosticUtil.createErrorPayloadWithErrorCode(
                    2001, false, CallDiagnosticConstants.error.name.MEDIA_ENGINE
                );
                CallDiagnosticUtil.sendCallDiagnosticEvent(
                    CallDiagnosticConstants.eventType.CLIENT_MEDIA_ENGINE_LOCAL_SDP_GENERATED, identifiers, {
                        canProceed: false, errors: [errorPayload]
                    }
                );
                console.error('PCUtils: `pc.createOffer` Error creating offer ', error);
                return Promise.reject(error);
            });
    }

    return Promise.reject(new Error('Invalid peerConnection'));
};

/*
* create offer with a valid paramater
* @param {Object} MainPeerconnetion
* @param {String} OFFER/ANSWER
* @sdp {String} SDP
* @param {Object} ScreenPeerconnetion
*/

PC.attachIceStateChange = (pc) => {
    // In case ICE fail
    pc.oniceconnectionstatechange = () => {
        switch (pc.iceConnectionState) {
            case MediaConstants.iceConnectionState.FAILED:
            case MediaConstants.iceConnectionState.DISCONNECTED:
                console.error(`Interactive Connectivity Establishment(ICE)${pc.iceConnectionState}!`, new Date());
                MeetingAdapter.onIceFailDiscRestart();
                break;
            default:
                break;
        }
    };
};

PC.creatOfferNew = (params) => {
    console.info('createOffer: creating a new offer');

    try {
        const pc = params.peerConnection
            || new window.RTCPeerConnection(
                bowser.firefox ? calls.rtcConfigurationFirefox : calls.rtcConfiguration
            );
        // No need to add for screen peerconnection
        if (params.streams) {
            PC.addStream(pc, params.streams);
        }

        const sdpConstraints = {
            offerToReceiveAudio: params.offerToReceiveAudio,
            offerToReceiveVideo: forceAudioCalls() ? params.offerToReceiveVideo : false
        };
        return pc.createOffer(sdpConstraints)
            .then((description) => {
                if (edonusHack()) {
                    description.sdp = description.sdp.replace(/recvonly.*/g, 'sendrecv');
                }
                return pc.setLocalDescription(description);
            })
            .then(() => PC.iceCandidate(pc))
            .then(() => {
                pc.sdp = limitBandwidth(pc.localDescription.sdp);
                pc.sdp = setMaxFs(pc.sdp);
                if (!checkH264Support(pc.sdp)) {
                    throw new Error('openH264 is downloading please Wait. Upload logs if not working on second try');
                }
                if (extmapFix()) {
                    pc.sdp = pc.sdp.replace(/\na=extmap.*/g, '');
                }
                PC.attachIceStateChange(pc);
                return pc;
            })
            .catch((e) => {
                throw e;
            });
    }
    catch (e) {
        console.error('createOffer: error while creating a offer ', e);
        throw e;
    }
};

/*
* rollBack local description in peerconnection
* @param {Object} PeerConnection
*/

PC.rollBackLocalDescription = (pc) => {
    console.info('rollBackLocalDescription: rollingbacking peerconnection');

    return pc.setLocalDescription(new RTCSessionDescription({ type: 'rollback' }))
        .then(() => pc)
        .catch((e) => {
            console.error('rollBackLocalDescription: Error while setting the Local Description ', e);
            return Promise.error(e);
        });
};

/*
* options {
*  offerToReceiveAudio: {Boolean} sdp constraints
*  offerToReceiveVideo: {Boolean} sdp constraints
*  offerSdp: {sdp}
*  stream: {PCStream}
* }
*/

PC.updatePeerConnection = (params) => {
    console.info('updatePeerConnection: updating the pc');

    const { pc, screenPc } = params;

    const screenConstraints = {
        offerToReceiveAudio: false,
        offerToReceiveVideo: true
    };
    const sdpConstraints = {
        offerToReceiveAudio: params.offerToReceiveAudio,
        offerToReceiveVideo: forceAudioCalls() ? params.offerToReceiveVideo : false
    };

    if (pc === undefined && screenPc) {
        return PC.createAnswer({
            pc: screenPc,
            screenConstraints,
            offerSdp: params.offerSdp[0]
        }).then((updatedScreenPc) => {
            updatedScreenPc.sdp += 'a=content:slides\r\n';
            return [updatedScreenPc.sdp];
        });
    }


    return Promise.all([
        PC.createAnswer({
            pc,
            sdpConstraints,
            offerSdp: params.offerSdp[0]
        }),
        PC.createAnswer({
            pc: screenPc,
            offerSdp: params.offerSdp[1],
            sdpConstraints: screenConstraints
        })
    ])
        .then(([updatedPc, updatedScreenPc]) => {
            screenPc.sdp += 'a=content:slides\r\n';
            return [updatedPc.sdp, updatedScreenPc.sdp];
        });
};

/*
* options {
*  pc: {Object} peerConnection
*  sdpConstraints: {Object} sdp constraints
* }
*/

PC.createAnswer = (params) => {
    const { pc } = params;

    // TODO: Some times to many mercury event comes at the same time
    // Need to maintain state of peerconnection
    if (pc.signalingState === 'have-remote-offer') {
        return Promise.resolve(pc);
    }

    return PC.setRemoteSessionDetails(pc, 'offer', params.offerSdp)
        .then(() => pc.createAnswer(params.sdpConstraints))
        .then((answer) => {
            if (edonusHack()) {
                answer.sdp = answer.sdp.replace(/recvonly.*/g, 'sendrecv');
            }
            return pc.setLocalDescription(answer);
        })
        .then(PC.iceCandidate(pc))
        .then(() => {
            pc.sdp = limitBandwidth(pc.localDescription.sdp);
            pc.sdp = setMaxFs(pc.sdp);
            if (!checkH264Support(pc.sdp)) {
                throw new Error('openH264 is downloading please Wait. Upload logs if not working on second try');
            }
            if (extmapFix()) {
                pc.sdp = pc.sdp.replace(/\na=extmap.*/g, '');
            }
            return pc;
        })
        .catch((e) => {
            console.error('updatePeerConnection: error while updating the PC ', e);
        });
};

PC.close = (pc) => {
    // pc.close() fails on firefox on network changes and gives a Dom exception
    // To avoid this we have added a try catch block.
    // Please refer to https://bugzilla.mozilla.org/show_bug.cgi?id=1274407 for more information
    console.info('PC: close() -> closing the peerConnection');
    try {
        if (pc && pc.close) {
            pc.close();
        }
        else {
            console.warn('Peer connection has no close');
        }
    }
    catch (e) {
        console.error('Error Cleaning Up the PeerConnection', e);
    }
};

// TODO create a media call metric module, factor this and other metrics out using stats media module
PC.getEndOfCallMetric = (locus, deviceUrl) => {
    const mediaStart = (locus.mediaTs && locus.requestTs) ? locus.mediaTs - locus.requestTs : -1;
    let totalScreenDuration = 0;
    if (locus.screenShares) {
        locus.screenShares.forEach((share) => {
            totalScreenDuration += (share.screenEnd - share.screenStart);
        });
    }
    let callOrigin = locus.callOrigin || MeetingConstants.callOrigin.unknown;
    if (locus.isZtm) {
        callOrigin = MeetingConstants.callOrigin.zeroTouchMeeting;
    }
    const report = {
        clientCallDuration: (locus.requestTs ? Date.now() - locus.requestTs : -1),
        cameraFailed: locus.cameraFailed,
        iceFailed: locus.peerConnection && locus.peerConnection.iceConnectionState !== 'succeeded',
        videoStart: mediaStart,
        audioStart: mediaStart,
        ztmStart: locus.ztmTs ? locus.ztmTs - Date.parse(locus.fullState.lastActive) : -1,
        isCaller: locus.self.isCreator,
        clientScreenDuration: totalScreenDuration,
        screenShareCount: locus.screenShares ? locus.screenShares.length : 0,
        // packetStats: PCStatsInterface.getPacketStats(),
        callOrigin
    };
    addBasicCallMetrics(locus, deviceUrl, report);
    return report;
};

PC.getCallAlertMetrics = (locus, deviceUrl) => {
    const report = {
        source: 'TOAST'
    };
    addBasicCallMetrics(locus, deviceUrl, report);
    return report;
};

PC.mergeSDP = (offerSDP, screenSDP) => {
    // Remove the previous content SDP
    const sdpSequenceNumber = offerSDP.match(/[o][=][-]?\s\d+\s(\d*).*/)[1];
    const sequenceNumber = parseInt(sdpSequenceNumber) + 1;
    // match returns 1st index as value
    // o: "o=- 1385469268498477104 3 IN IP4 127.0.0.1"
    // 1:"3"

    const mainSDP = offerSDP.replace(`${sdpSequenceNumber} IN IP4`, `${sequenceNumber} IN IP4`);

    const mainPc = mainSDP.split('m=video');
    return `${mainPc[0]}m=video ${mainPc[1]}m=video ${screenSDP.split('m=video ')[1]}`;
};

export default PC;
