/* globals window, RTCSessionDescription */

import bowser from 'bowser';
import sdpTransform from 'sdp-transform';

import {calls, meetings} from '../constants/meeting-constant.js';
// import MeetingConfig from '../meetings/meeting-config';
// import MediaConstants from '../../utils/MediaConstants';

const PC = {};

const setMaxFs = (sdp) => {
  let replaceSdp = sdp;
  const payloadTypes = sdp.match(/\na=fmtp:(\d+).*level-asymmetry-allowed=1.*/g);
  if (payloadTypes) {
    payloadTypes.forEach((payload) => {
      replaceSdp = replaceSdp.replace(payload, `${payload};max-fs=8160`);
    });
  }
  return replaceSdp;
};

const checkH264Support = (sdp) => {
  const videoPresent = sdp.match(/\nm=video.*/g);
  const h264Present = sdp.match(/\na=rtpmap:\d+\sH264.*/g);

  if (videoPresent) {
    return !!h264Present;
  }
  return true;
};

const validateSdp = (sdp) => {
  // https://github.com/clux/sdp-transform
  const parsedSdp = sdpTransform.parse(sdp);

  parsedSdp.media.forEach((mediaLine) => {
    if (mediaLine.candidates && mediaLine.candidates.length === 0) {
      console.error('iceCandidate: Ice candadate never completed');
      return false;
    }
    if ([9, 0].includes(mediaLine.port)) {
      console.error('iceCandidate: Found invalid port number for the ice candidate');
      return false;
    }
    if (!mediaLine.icePwd || !mediaLine.iceUfrag) {
      console.error('iceCandidate: ice ufrag and password not found');
      return false;
    }
    return true;
  });
};

const insertBandwidthLimit = (sdpLines, index) => {
  let limit;
  if (sdpLines[index].search('audio') !== -1) {
    limit = meetings.audioBandwidthLimit;
  }
  else {
    limit = meetings.videoBandwidthLimit;
  }
  sdpLines.splice(index + 1, 0, `b=TIAS:${limit}`);
  return sdpLines;
};

const limitBandwidth = (offerSdp) => {
  let sdp = offerSdp;
  let sdpLines = sdp.split('\r\n');

  for (let i = 0; i < sdpLines.length; i += 1) {
    if (sdpLines[i].search('m=') !== -1) {
      sdpLines = insertBandwidthLimit(sdpLines, i);
    }
  }
  sdp = sdpLines.join('\r\n');
  return sdp;
};

PC.iceCandidate = (pc) =>
  new Promise((resolve) => {
    // TODO: we dont need timeout as we can check the api state and validate.
    const timeout = setTimeout(() => {
      pc.sdp = limitBandwidth(pc.localDescription.sdp);
      pc.sdp = setMaxFs(pc.sdp);

      pc.sdp = pc.sdp.replace(/\na=extmap.*/g, '');

      // TODO: Adding this as a precation if the ice gathering doesnt happen with in 3 sec
      // We will wait for another 3 sec to respond
      if (!validateSdp(pc.sdp)) {
        setTimeout(() => {
          resolve(pc);
        }, meetings.retryTimeout);
      }
      else {
        resolve(pc);
      }
    }, meetings.iceTimeout);

    pc.onicecandidate = (evt) => {
      if (!evt.candidate && !pc.sdp) {
        // pc.sdp = pc.localDescription.sdp
        // TODO: CHECK why do we need this

        pc.sdp = limitBandwidth(pc.localDescription.sdp);
        pc.sdp = setMaxFs(pc.sdp);
        pc.sdp = pc.sdp.replace(/\na=extmap.*/g, '');
        if (evt.candidate === null) {
          validateSdp(pc.sdp);
          clearTimeout(timeout);
          resolve(pc);
        }
      }
    };
  });

// TODO: WIP there is a issue with firefox
PC.replaceTrack = (pc, track) => {
  try {
    const senders = pc.getSenders();
    if (senders.length > 0) {
      senders.forEach((sender) => {
        if (sender.track && sender.track.kind === track.kind) {
          sender.replaceTrack(track);
        }
      });
    }
  }
  catch (e) {
    console.error('replaceTrack: Error while replacing Tracks ', e);
  }
};

/*
* adding streams to mediaPeerConnection
* @param {Object} peerconnetion
* @param {Object} stream
*/

PC.addStream = (pc, stream) => {
  console.info('addStream: adding streams to peerconnection');

  try {
    if (stream && !bowser.msedge) {
      const tracksPresent = pc.getSenders && pc.getSenders().find((sender) => sender.track != null);
      if (tracksPresent) {
        stream.getTracks().forEach((track) => {
          PC.replaceTrack(pc, track);
        });
        return;
      }
      stream.getTracks().forEach((track) => {
        pc.addTrack(track, stream);
      });
      // // TODO : may come back disable addTracks for chrome they are moving back to addStream
      // // https://bugs.chromium.org/p/chromium/issues/detail?id=764414
      // // https://bugs.chromium.org/p/chromium/issues/detail?id=738918#c7
      //   pc.addStream(stream);
    }
    else if (bowser.msedge) {
      pc.addStream(stream);
    }
    else {
      console.error('addStream: No streams to add');
    }
  }
  catch (e) {
    console.error('addStream: Error while adding Stream ', e);
  }
};

// TODO : This is only used by screen share so assumeing all the stream
// in pc belongs to content
// So we are not passing sender of the stream to remove but just removing all the tracks
PC.removeStream = (pc, stream) => {
  console.info('removeStream: removing streams from peerconnection');
  try {
    const senders = pc && pc.getSenders();
    if (stream) {
      // TODO : disable removeTracks for chrome they are moving back to addStream
      // https://bugs.chromium.org/p/chromium/issues/detail?id=764414
      // https://bugs.chromium.org/p/chromium/issues/detail?id=738918#c7
      if (pc.removeTrack && senders && senders.length > 0) {
        senders.forEach((sender) => {
          pc.removeTrack(sender);
        });
      }
      else {
        pc.removeStream(stream);
      }
    }
    else {
      console.error('removeStream: No streams to remove');
    }
  }
  catch (e) {
    console.error('removeStream: Error while removing Stream ', e);
  }
};

/*
* setting the remote description
* @param {Object} MainPeerconnetion
* @param {String} OFFER/ANSWER
* @sdp {String} SDP
* @param {Object} ScreenPeerconnetion
*/

PC.setRemoteSessionDetails = (pc, typeStr, remoteSdp) => {
  const {screenPeerConnection} = pc;
  console.info(`Setting the remote description type: ${typeStr}State: ${pc.signalingState}`);
  const promiseSdp = [];
  let sdp = remoteSdp;

  sdp = sdp.replace(/\na=extmap.*/g, '');

  const mlines = sdp.split('m=');
  if (mlines.length === 4 && screenPeerConnection) {
    sdp = `${mlines[0]}m=${mlines[1]}m=${mlines[2]}`;
    const contentSdp = `${mlines[0]}m=${mlines[3]}`;
    promiseSdp.push(
      screenPeerConnection.setRemoteDescription(
        new window.RTCSessionDescription({
          type: typeStr,
          sdp: contentSdp
        })
      )
    );
  }

  // making sure that the remoteDescription is only set when there is a answer for offer
  // or there is a offer from the server
  if (pc.signalingState === 'have-local-offer' || (pc.signalingState === 'stable' && typeStr === 'offer')) {
    promiseSdp.push(
      pc.setRemoteDescription(
        new window.RTCSessionDescription({
          type: typeStr,
          sdp
        })
      )
    );
  }
  return Promise.all(promiseSdp).catch((e) => {
    console.error('Error setting the remoteDescription', e);
    return Promise.reject(e);
  });
};

/*
* create offer with a valid paramater
* @param {Object} MainPeerconnetion
* @param {String} OFFER/ANSWER
* @sdp {String} SDP
* @param {Object} ScreenPeerconnetion
*/

// PC.attachIceStateChange = (pc) => {
//   // In case ICE fail
//   pc.oniceconnectionstatechange = () => {
//     switch (pc.iceConnectionState) {
//       case MediaConstants.iceConnectionState.FAILED:
//       case MediaConstants.iceConnectionState.DISCONNECTED:
//         console.error(`Interactive Connectivity Establishment(ICE)${pc.iceConnectionState}!`, new Date());
//         // MeetingAdapter.onIceFailDiscRestart();
//         break;
//       default:
//         break;
//     }
//   };
// };

PC.createOffer = (params) => {
  console.info('createOffer: creating a new offer');

  try {
    const pc
      = params.mediaPeerConnection
      || new window.RTCPeerConnection(bowser.firefox ? calls.rtcConfigurationFirefox : calls.rtcConfiguration);
    // No need to add for screen peerconnection
    if (params.streams && Array.isArray(params.streams)) {
      PC.addStream(pc, params.streams[0]);
    }
    else {
      if (params.streams) {
        PC.addStream(pc, params.streams);
      }
    }

    const sdpConstraints = {
      offerToReceiveAudio: params.receiveAudio,
      offerToReceiveVideo: params.receiveVideo
    };
    return pc
      .createOffer(sdpConstraints)
      .then((description) =>
        // if (edonusHack()) {
        //   description.sdp = description.sdp.replace(/recvonly.*/g, 'sendrecv');
        // }
        pc.setLocalDescription(description))
      .then(() => PC.iceCandidate(pc))
      .then(() => {
        pc.sdp = limitBandwidth(pc.localDescription.sdp);
        pc.sdp = setMaxFs(pc.sdp);
        if (!checkH264Support(pc.sdp)) {
          throw new Error('openH264 is downloading please Wait. Upload logs if not working on second try');
        }

        pc.sdp = pc.sdp.replace(/\na=extmap.*/g, '');

        // PC.attachIceStateChange(pc);
        return pc;
      })
      .catch((e) => {
        throw e;
      });
  }
  catch (e) {
    console.error('createOffer: error while creating a offer ', e);
    throw e;
  }
};

/*
* rollBack local description in peerconnection
* @param {Object} PeerConnection
*/

PC.rollBackLocalDescription = (pc) => {
  console.info('rollBackLocalDescription: rollingbacking peerconnection');

  return pc
    .setLocalDescription(new RTCSessionDescription({type: 'rollback'}))
    .then(() => pc)
    .catch((e) => {
      console.error('rollBackLocalDescription: Error while setting the Local Description ', e);
      return Promise.error(e);
    });
};

/*
* options {
*  offerToReceiveAudio: {Boolean} sdp constraints
*  offerToReceiveVideo: {Boolean} sdp constraints
*  offerSdp: {sdp}
*  stream: {PCStream}
* }
*/

PC.updatePeerConnection = (params) => {
  console.info('updatePeerConnection: updating the pc');

  const {pc, screenPeerConnection} = params;

  const screenConstraints = {
    offerToReceiveAudio: false,
    offerToReceiveVideo: true
  };
  const sdpConstraints = {
    offerToReceiveAudio: params.offerToReceiveAudio,
    offerToReceiveVideo: params.offerToReceiveVideo
  };

  if (pc === undefined && screenPeerConnection) {
    return PC.createAnswer({
      pc: screenPeerConnection,
      screenConstraints,
      offerSdp: params.offerSdp[0]
    }).then((updatedScreenPc) => {
      updatedScreenPc.sdp += 'a=content:slides\r\n';
      return [updatedScreenPc.sdp];
    });
  }

  return Promise.all([
    PC.createAnswer({
      pc,
      sdpConstraints,
      offerSdp: params.offerSdp[0]
    }),
    PC.createAnswer({
      pc: screenPeerConnection,
      offerSdp: params.offerSdp[1],
      sdpConstraints: screenConstraints
    })
  ]).then(([updatedPc, updatedScreenPc]) => {
    screenPeerConnection.sdp += 'a=content:slides\r\n';
    return [updatedPc.sdp, updatedScreenPc.sdp];
  });
};

/*
* options {
*  pc: {Object} mediaPeerConnection
*  sdpConstraints: {Object} sdp constraints
* }
*/

PC.createAnswer = (params) => {
  const {pc} = params;

  // TODO: Some times to many mercury event comes at the same time
  // Need to maintain state of peerconnection
  if (pc.signalingState === 'have-remote-offer') {
    return Promise.resolve(pc);
  }

  return PC.setRemoteSessionDetails(pc, 'offer', params.offerSdp)
    .then(() => pc.createAnswer(params.sdpConstraints))
    .then((answer) =>
      //   if (edonusHack()) {
      //     answer.sdp = answer.sdp.replace(/recvonly.*/g, 'sendrecv');
      //   }
      pc.setLocalDescription(answer))
    .then(PC.iceCandidate(pc))
    .then(() => {
      pc.sdp = limitBandwidth(pc.localDescription.sdp);
      pc.sdp = setMaxFs(pc.sdp);
      if (!checkH264Support(pc.sdp)) {
        throw new Error('openH264 is downloading please Wait. Upload logs if not working on second try');
      }

      pc.sdp = pc.sdp.replace(/\na=extmap.*/g, '');

      return pc;
    })
    .catch((e) => {
      console.error('updatePeerConnection: error while updating the PC ', e);
    });
};

PC.close = (pc) => {
  // pc.close() fails on firefox on network changes and gives a Dom exception
  // To avoid this we have added a try catch block.
  // Please refer to https://bugzilla.mozilla.org/show_bug.cgi?id=1274407 for more information
  console.info('PC: close() -> closing the mediaPeerConnection');
  try {
    if (pc && pc.close) {
      pc.close();
    }
    else {
      console.warn('Peer connection has no close');
    }
  }
  catch (e) {
    console.error('Error Cleaning Up the PeerConnection', e);
  }
};

export default PC;
