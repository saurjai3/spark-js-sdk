/*!
 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
 */
/* globals navigator */
/**
 *
 * Mimic browser APIs as "the ultimate browser".
 * Handles the quirks of each browser.
 * Extends and enhances adapter.js, i.e., the "media" file from the web client.
 * @export
 * @class Media
 */
export default class Media {
  /**
   * Create an instance of Media.
   * @param {object} devices
   * @param {object} streams
   * @memberof Media
   */
  constructor(devices, streams) {
    this.devices = devices;
    this.streams = streams;
  }

  // TODO:Check if oneonone is needed
  /**
  * generates audio,video and screen stream using constrains (often called after getSupportedDevices)
  * @param {Object} audio {
  *  sendAudio: {Boolean} gum constraints
  *  sendVideo: {Boolean} gum constraints
  *  sendScreen: {Boolean} gum constraints
  *  mediaSource: {String} screen|camera|tab|application; gum constraints
  * }
  * @memberof Media
  * @returns {Object} {streams}
  */

  getMedia(video, audio) {
    this.funcName = 'getMedia';
    // fake media used for test environment, which does not require webcam and microphone
    // TODO: becuase the .spread oprator needs a promise array we have to return this as promise
    // For some reason navigator.mediaDevices.getUserMedia does not give you screen sharing so moving to older way
    // "Error: The request is not allowed by the user agent or the platform in the current context. "

    const mediaconfig = {
      audio,
      video
    };

    return new Promise(((resolve, reject) => {
      navigator.mediaDevices.getUserMedia(mediaconfig)
        .then((stream) => {
          resolve(stream);
        })
        .catch((msg) => {
          /* eslint-disable */
            reject({
              name: msg.name,
              localMediaFailed: true,
              cameraFailed: msg === mediaconfig.permissionDenied
            });
            /* eslint-enable */
        });
    }));
  }


  /**
  * Checks if the machine has at least one audio or video device (Dont use this for screen share)
  * optional param
  * @memberof Media
  * @param {object} {
      sendAudio: true/false,
      sendVideo: true/false
  }
  * @return {Object} {
  *    sendAudio: true/false,
  *    sendVideo: true/false
  *}
  */

  getSupportedDevice(options = {
    sendAudio: true,
    sendVideo: true
  }) {
    const constrains = options;

    // TODO we've been defaulting to sendVideo=sendAudio=true for old browsers, which sometimes don't populate
    // mediaDevices even though video/audio devices are present. But this isn't what we'd expect
    // for browsers that do accurately populate mediaDevices. Can add nuance in future...
    if (!navigator.mediaDevices || navigator.mediaDevices.enumerateDevices === undefined) {
      return Promise.resolve({sendAudio: true, sendVideo: true});
    }

    return new Promise(((resolve, reject) => {
      navigator.mediaDevices.enumerateDevices()
        .then((devices) => {
          const supported = {
            audio: devices.filter((device) => device.kind === 'audioinput').length > 0,
            video: devices.filter((device) => device.kind === 'videoinput').length > 0
          };

          resolve({
            sendAudio: (supported.audio && constrains.sendAudio),
            sendVideo: (supported.video && constrains.sendVideo)
          });
        })
        .catch((err) => {
          console.error(`Not able to get supported device${err.name}: ${err.message}`);
          reject(err);
        });
    }));
  }

  /**
   *
   * Toggle a specific stream
   * @returns {null}
   * @memberof Media
   */
  toggleStream() {}

  /**
   *
   * Stop input stream
   * @returns {null}
   * @memberof Media
   */
  stopStream() {}
}
