/* eslint require-jsdoc:0 */
import MeetingCollection from '../meetings/collection';
import {ROAP} from '../constants';

import RoapHandler from './roap-handler';
import RoapAdapter from './roap-adapter';

const RoapInterface = {
  sendRoapOK(options) {
    const meeting = MeetingCollection.get(options.correlationId);
    if (options.locusSelfId === undefined) {
      // There is a race conditation where the locus response comes after mercury event
      // holsted (11/6/18): How can we prevent the race condition ^
      return;
    }

    const roapMessage = {
      messageType: ROAP.roapTypes.OK,
      version: ROAP.ROAP_VERSION,
      seq: options.seq
    };

    RoapAdapter.sendRoap({
      roapMessage,
      locusId: options.locusId,
      locusSelfId: options.locusSelfId,
      mediaId: options.mediaId,
      correlationId: options.correlationId
    }).then(() => {
      // TODO: need to check where to save the current seq number
      // MeetingServerActionCreators.selfChanged({ locus: locus });

      RoapHandler.submit({
        type: ROAP.SEND_ROAP_MSG,
        msg: roapMessage,
        correlationId: options.correlationId
      });

      meeting.updateRoapSeq(options.seq);
    });
  },

  // TODO: try to merge sendRoapOk and roapAnswer
  sendRoapAnswer(options) {
    const meeting = MeetingCollection.get(options.correlationId);
    const roapMessage = {
      messageType: ROAP.roapTypes.ANSWER,
      sdps: options.sdps,
      version: ROAP.ROAP_VERSION,
      seq: options.roapSeq
    };

    RoapAdapter.sendRoap({
      roapMessage,
      locusId: options.locusId,
      locusSelfId: options.locusSelfId,
      mediaId: options.mediaId,
      correlationId: options.correlationId
    }).then((/* locus */) => {
      meeting.updateRoapSeq(options.seq);
      RoapHandler.submit({
        type: ROAP.SEND_ROAP_MSG,
        msg: roapMessage,
        correlationId: options.correlationId
      });
    });
  },

  sendRoapError(session, locus, errorType) {
    const msg = {
      messageType: ROAP.roapTypes.ERROR,
      version: ROAP.ROAP_VERSION,
      errorType,
      seq: session.OFFER.seq
    };

    RoapAdapter.sendRoap(msg, locus);
  },

  resetRoap(correlationId) {
    RoapHandler.submit({
      type: ROAP.RECEIVE_CALL_LEAVE,
      correlationId
    });
  },

  sendRoapMediaRequest(options) {
    const {meeting} = options;
    const roapMessage = {
      messageType: ROAP.roapTypes.OFFER,
      sdps: options.sdps,
      version: ROAP.ROAP_VERSION,
      seq: typeof options.roapSeq !== 'number' && Number.isNaN(parseFloat(options.roapSeq)) ? 0 : options.roapSeq + 1,
      tieBreaker: 4294967294 // Math.floor(Math.random() * (2 ** 32) - 1) // TODO: Handle the roap  conflict scenario
    };

    RoapHandler.submit({
      type: ROAP.SEND_ROAP_MSG,
      msg: roapMessage,
      correlationId: meeting.correlationId
    });

    return RoapAdapter.sendRoap({
      roapMessage,
      correlationId: meeting.correlationId,
      locusId: meeting.locusId,
      locusSelfId: meeting.selfId, // locusSelfId ???
      mediaId: meeting.mediaId,
      audioMuted: meeting.audioMuted,
      videoMuted: meeting.videoMuted
    }).then((locus) => {
      RoapHandler.submit({
        type: ROAP.SEND_ROAP_MSG_SUCCESS,
        seq: roapMessage.seq,
        correlationId: meeting.correlationId
      });
      meeting.updateRoapSeq(roapMessage.seq);
      // TODO: we need to attach peerconenction to locus not sure if we need to pass everything here
      // MeetingServerActionCreators.locusJoin(locus);
      // MediaUtil.setMetricCallback(self.reportSharing.bind(self, locus));
      return locus;
      // TODO: check where to update the sequence number
    });
  }
};

export default RoapInterface;
