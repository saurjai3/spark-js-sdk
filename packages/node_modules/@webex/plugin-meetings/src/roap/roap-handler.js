/* eslint require-jsdoc:0 */
/* globals window */

// import MeetingClientActionCreators from '../meetings/meeting-client-action-creators';
import Meetings from './../meetings';
// import * as config from '../../constants/config';
// import Constants from '../../constants/Constants';
import PeerConnectionManager from './../PeerConnectionManager';

import RoapConstants from './roap-constants';
import RoapInterface from './roap-interface';

const config = window;

const RoapHandler = {

  sessions: {},

  // returns true if a state update is to be triggered
  save(roap) {
    const {correlationId} = roap;
    const sequenceId = roap.msg.seq;

    config.console.info('Call-RoapHandler: CorrelationID, ', roap.correlationId);

    const meeting = Meetings.get(roap.correlationId);
    if (roap.msg.messageType === 'ERROR' && roap.msg.errorType === 'CONFLICT') {
      // reset the peer-connection and send the request

      PeerConnectionManager
        .rollBackLocalDescription({peerConnection: meeting.peerConnection})
        .then(() => {
          config
            .console
            .info('Delete the sequence data ', roap.msg.seq);

          // TODO: Reset locus and share again after you get the next offer or after a
          // time-interval ,
          // TODO: remove any reference to callStore and simplify or merge the callStore
          // and RoapHandler
          if (meeting) {
            config
              .console
              .info('emitting the callStore changes');
            meeting.shareStatus = 'IDLE';

            // TODO: reset the roap state and peerconnection
            // MeetingStore.emit(CHANGE_EVENT);
          }
          delete RoapHandler.sessions[correlationId][sequenceId];
        })
        .catch((err) => {
          config
            .console
            .info('Cannot reset the peerconncetion', err);
        });
      return false;
    }

    this.sessions[correlationId] = this.sessions[correlationId] || {};
    this.sessions[correlationId][sequenceId] = this.sessions[correlationId][sequenceId] || {};

    if (this.sessions[correlationId][sequenceId].OFFER && roap.msg.messageType === 'OFFER') {
      this.sessions[correlationId][sequenceId].GLARE_OFFER = roap.msg;
      this.sessions[correlationId][sequenceId].GLARE_OFFER.remote = !!roap.remote;
      config
        .console
        .info(`Its a GLARE condition seq:${sequenceId} new mercury event`);
    }
    else {
      config
        .console
        .info(`Save OFFER/ANSWER seq:${sequenceId} new mercury event ${roap.msg.messageType}local state: ${JSON.stringify(this.sessions[correlationId][sequenceId].state, null, 2)}`);
      this.sessions[correlationId][sequenceId][roap.msg.messageType] = roap.msg;
      this.sessions[correlationId][sequenceId][roap.msg.messageType].remote = !!roap.remote;
    }

    if (meeting) {
      if (roap.msg.messageType === 'OFFER' && roap.remote && meeting.shareStatus === 'REQUESTED') {
        // The peer-connection is waiting for answer but got an offer Reset and try to
        // send the offer later after you accept the answer
        config
          .console
          .info(`Call-RoapHandler:The peer-connection has changed before sending the request:${sequenceId}`);
        // Roapint.sendRoapError(RoapHandler.sessions[correlationId][sequenceId], MeetingStore.calls[correlationId], 'CONFLICT');
        return false;
      }
    }

    // initialize state
    if (!this.sessions[correlationId][sequenceId].state) {
      this.sessions[correlationId][sequenceId].state = RoapConstants.RoapState.INIT;
    }

    // Assuming the mercury event has come first before the response for the event
    // we have to wait for the response and trigger the ROAP request later on
    if (meeting && (!meeting.peerConnection && !meeting.screenPc) && roap.msg.messageType === 'ANSWER') {
      config
        .console
        .info(`Call-RoapHandler: Got RemoteSdp Mercury event before \`/participants\` response correlationId: ${correlationId}`);
      return false;
    }

    config
      .console
      .info('Call-RoapHandler: success save proceeding with transition, ', roap.msg);

    return true;
  },

  /* eslint-disable no-empty */
  // jscs:disable

  // signal: action perfomed and signaled
  // session: current session Object
  // meeting: meeting object
  transition(signal, session, meeting) {
    const prevState = session.state;
    config
      .console
      .info('Call-RoapHandler# Current state %s action %s', prevState, signal);

    switch (session.state) {
      case RoapConstants.RoapState.INIT:
        if (signal === RoapConstants.RoapSignal.RX_OFFER) {
          session.state = RoapConstants.RoapState.WAIT_TX_ANSWER;
        }
        else if (signal === RoapConstants.RoapSignal.TX_OFFER) {
          session.state = RoapConstants.RoapState.WAIT_RX_ANSWER;
        }
        break;

      case RoapConstants.RoapState.WAIT_RX_OFFER:
        break;
      case RoapConstants.RoapState.WAIT_RX_ANSWER:
        if (signal === RoapConstants.RoapSignal.RX_ANSWER) {
          // There is a race condition where the /call response comes after mercury event from the server
        // As mercury sends roap event if it didnt get back a response. We can send the roap ok after that
          if (meeting.mediaId) {
            session.state = RoapConstants.RoapState.WAIT_TX_OK;
          }
          else {
            config
              .console
              .error('Call-RoapHandler#Race Condition no mediaId');
          }
        }
        else if (signal === RoapConstants.RoapSignal.RX_OFFER) {
          session.state = RoapConstants.RoapState.GLARE;
        }
        break;

      case RoapConstants.RoapState.WAIT_TX_OFFER:
        break;
      case RoapConstants.RoapState.WAIT_TX_ANSWER:
        if (signal === RoapConstants.RoapSignal.TX_ANSWER) {
          session.state = RoapConstants.RoapState.WAIT_RX_OK;
        }
        break;

      case RoapConstants.RoapState.WAIT_TX_OK:
        if (signal === RoapConstants.RoapSignal.TX_OK) {
          session.state = RoapConstants.RoapState.INIT;
        }
        break;
      case RoapConstants.RoapState.WAIT_RX_OK:
        if (signal === RoapConstants.RoapSignal.RX_OK) {
          session.state = RoapConstants.RoapState.INIT;
        }
        break;
      case RoapConstants.RoapState.ERROR:
        // TODO: resolve error state. Add a signal constant and handle the cleanup
        session.state = RoapConstants.RoapState.INIT;
        break;
      case RoapConstants.RoapState.GLARE:
        session.state = RoapConstants.RoapState.WAIT_RX_ANSWER;
        break;
      default:
        break;
    }

    if (!session.state) {
      config
        .console
        .error('Call-RoapHandler#transition invalid state', session);
    }
    // TODO emit with pub sub for the state transition for any listeners that need the update
    // RoapHandler.emit(Constants.ROAP_TRANSITION, session.state);
    config
      .console
      .info('Call-RoapHandler# transition roapSeq %d , %s : %s to %s ', session.OFFER ? session.OFFER.seq : null, signal, prevState, session.state);
    RoapHandler.performState(session, meeting);
  },

  performState(session, meeting) {
    config
      .console
      .info('CALL-RoapHandler: PerfomeState ', session.state);

    const setRemoteDescription = () => {
      config
        .console
        .info('Call-RoapHandler: Transmite WAIT_TX_OK', meeting.correlationId);

      // if (meeting && meeting.shareStatus === 'REQUESTED') {
      //   MeetingClientActionCreators.sendFloorGrant(meeting);
      // }

      // remove this TODO

      if (!(meeting && (meeting.peerConnection || meeting.screenPc))) {
        config
          .console
          .error('Call-RoapHandler: DANGER no meeting or peerconnection', meeting.correlationId);
        return;
      }
      let promise;
      if (meeting.peerConnection && meeting.screenPc) {
        promise = Promise.all([PeerConnectionManager.setRemoteSessionDetails(meeting.peerConnection, 'answer', session.ANSWER.sdps[0], meeting.clientIdentifiers),
          PeerConnectionManager.setRemoteSessionDetails(meeting.screenPc, 'answer', session.ANSWER.sdps[1], meeting.clientIdentifiers)
        ]);
      }
      else if (meeting.screenPc) {
        promise = PeerConnectionManager.setRemoteSessionDetails(meeting.screenPc, 'answer', session.ANSWER.sdps[0], meeting.clientIdentifiers);
      }
      promise
        .then(() => {
          config
            .console
            .info('Call-RoapHandler: setRemote Description successfull', meeting.correlationId);

          return RoapInterface.sendRoapOK({
            seq: session.ANSWER.seq,
            locusId: meeting.locusId,
            locusSelfId: meeting.locus.self.id,
            mediaId: meeting.mediaId,
            correlationId: meeting.correlationId
          });
        })
        .catch((err) => {
          config
            .console
            .error('Call-RoapHandler: Error setting remote and sending Roap Message', err);
        });
    };

    switch (session.state) {
      // case RoapConstants.RoapState.INIT:
      // case RoapConstants.RoapState.WAIT_RX_OFFER:
      // case RoapConstants.RoapState.WAIT_RX_ANSWER:
      // case RoapConstants.RoapState.WAIT_RX_OK:

      // TODO: default audio and video , change later
      case RoapConstants.RoapState.WAIT_TX_ANSWER:
      // TODO: sometime the you get an answer while you are creating an offer so SKIP
      // Server will send the mercury event comes back

        if (meeting.pc && meeting.pc.signalingState === 'have-local-offer'
          || meeting.screenPc && meeting.screenPc.signalingState === 'have-local-offer') {
          return;
        }

        PeerConnectionManager.updatePeerConnection({
          offerSdp: session.OFFER.sdps,
          pc: meeting.peerConnection,
          screenPc: meeting.screenPc,
          offerToReceiveAudio: true,
          offerToReceiveVideo: true
        })
          .then((answerSdps) => {
            RoapInterface.sendRoapAnswer({
              locusId: meeting.locusId,
              locusSelfId: meeting.locus.self.id,
              mediaId: meeting.mediaId,
              sdps: answerSdps,
              roapSeq: session.OFFER.seq,
              correlationId: meeting.correlationId
            });
          });
        break;
      case RoapConstants.RoapState.WAIT_TX_OK:
        setRemoteDescription();
        break;
      // case RoapConstants.RoapState.IDLE_LOCAL_OFFER:
      case RoapConstants.RoapState.ERROR:
        config
          .console
          .error('Call-RoapHandler#ERROR state=error', session);
        break;
      case session.state === RoapHandler.GLARE:
        session.GLARE_OFFER.tieBreaker = session.GLARE_OFFER.tieBreaker || 0;
        session.OFFER.tieBreaker = session.OFFER.tieBreaker || 0;
        config
          .console
          .error('Resolve the GLARE condition');
        if (session.GLARE_OFFER.tieBreaker < session.OFFER.tieBreaker) {
          // 2
          config
            .console
            .error('local offer wins');
        }
        else {
          config
            .console
            .error('remote offer wins', session);
        }
        this.transition(RoapConstants.RoapSignal.GLARE_RESOLVED, session, meeting);
        break;
      default:
        break;
    }
  },

  submit(action) {
    let session;
    const {correlationId} = action;
    const meeting = Meetings.get(correlationId);
    let signal;
    let logging = true;

    switch (action.type) {
      case RoapConstants.RECEIVE_ROAP_MSG:
        // TODO: handle incomplete sequences

        if (!meeting) {
          // There should be a meeting object for each roap call associated
          config
            .console
            .error('Call-RoapHandler#RECEIVE_ROAP_MSG: should always have meeting object on roap event');
          break;
        }
        action.remote = true;
        if (RoapHandler.save(action)) {
          session = RoapHandler.sessions[correlationId][action.msg.seq];
          signal = RoapConstants.RoapSignal[`RX_${action.msg.messageType}`];
          RoapHandler.transition(signal, session, meeting);
        }
        break;

      case RoapConstants.SEND_ROAP_MSG:
        // TODO: handle incomplete sequences
        if (!meeting) {
          // There should be a meeting object for each roap call associated
          config
            .console
            .error('Call-RoapHandler#SEND_ROAP_MSG: should always have meeting object on roap event');
          break;
        }
        action.local = true;
        if (RoapHandler.save(action)) {
          session = RoapHandler.sessions[correlationId][action.msg.seq];
          signal = RoapConstants.RoapSignal[`TX_${action.msg.messageType}`];
          RoapHandler.transition(signal, session, meeting);
        }
        break;

      case RoapConstants.SEND_ROAP_MSG_SUCCESS:
        session = RoapHandler.sessions[correlationId][action.seq];

        if (!meeting) {
          // There should be a meeting object for each roap call associated
          config
            .console
            .error('Call-RoapHandler#SEND_ROAP_MSG_SUCCESS: should always have meeting object on roap event');
          break;
        }
        // This means we got and answer and waiting for 200 ok for /participants
        if (RoapHandler.sessions && RoapHandler.sessions[correlationId][action.seq].ANSWER) {
          signal = RoapConstants.RoapSignal.RX_ANSWER;
          // NOTE: When server send back an answer via mercury the
          // remote SDP is already saved sent and ok message is sent back
          // We dont have to indicate the roapHandler about the RX_ANSWER via SEND_ROAP_MSG_SUCCESS
          // RoapHandler.transition(signal, session, meeting);
        }
        break;

      case 'RECEIVE_CALL_LEAVE':
        delete RoapHandler.sessions[correlationId];
        config
          .console
          .info('Call-RoapHandler#RECEIVE_CALL_LEAVE: cleaning up the RoapHandler', correlationId);
        break;
      case RoapConstants.RESET_ROAP_STATE:
        delete RoapHandler.sessions[correlationId][action.msg.seq];
        config
          .console
          .info('Call-RoapHandler#RESET_ROAP_STATE: resetting the RoapHandler state', action.msg.seq);
        break;
      default:
        logging = false;
        return true;
    }

    if (logging) {
      config
        .console
        .log('Call-RoapHandler: Event %s ,  %s , %s', action.type, correlationId, action.msg);
    }
    return true;
  }
};

window.RoapHandler = RoapHandler;

export default RoapHandler;
