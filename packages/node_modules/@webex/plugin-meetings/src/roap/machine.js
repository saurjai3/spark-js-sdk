import StateMachine from 'javascript-state-machine';

import {ROAP} from '../constants';

const RoapStateMachine = {

  /* eslint-disable */
  createState() {
    let RoapState = StateMachine.factory({
        init: ROAP.ROAP_STATE.INIT,
        transitions: [
          {
            name: 'step',
            from: '*',
            to: function (signal, meeting) {
              let value = this.state;
              switch (this.state) {
                case ROAP.ROAP_STATE.INIT:
                  if (signal === ROAP.ROAP_SIGNAL.RX_OFFER) {
                    value = ROAP.ROAP_STATE.WAIT_TX_ANSWER;
                  }
                  else if (signal === ROAP.ROAP_SIGNAL.TX_OFFER) {
                    value = ROAP.ROAP_STATE.WAIT_RX_ANSWER;
                  }
                  break;
                case ROAP.ROAP_STATE.WAIT_RX_OFFER:
                  break;
                case ROAP.ROAP_STATE.WAIT_RX_ANSWER:
                  if (signal === ROAP.ROAP_SIGNAL.RX_ANSWER) {
                    // There is a race condition where the /call response comes after mercury event from the server
                    // As mercury sends roap event if it didnt get back a response. We can send the roap ok after that
                    if (meeting.mediaId) {
                      value = ROAP.ROAP_STATE.WAIT_TX_OK;
                    }
                    else {
                      config.console.error('Call-RoapHandler#Race Condition no mediaId');
                    }
                  }
                  else if (signal === ROAP.ROAP_SIGNAL.RX_OFFER) {
                    value = ROAP.ROAP_STATE.GLARE;
                  }
                  break;
                case ROAP.ROAP_STATE.WAIT_TX_OFFER:
                  break;
                case ROAP.ROAP_STATE.WAIT_TX_ANSWER:
                  if (signal === ROAP.ROAP_SIGNAL.TX_ANSWER) {
                    value = ROAP.ROAP_STATE.WAIT_RX_OK;
                  }
                  break;
                case ROAP.ROAP_STATE.WAIT_TX_OK:
                  if (signal === ROAP.ROAP_SIGNAL.TX_OK) {
                    value = ROAP.ROAP_STATE.INIT;
                  }
                  break;
                case ROAP.ROAP_STATE.WAIT_RX_OK:
                  if (signal === ROAP.ROAP_SIGNAL.RX_OK) {
                    value = ROAP.ROAP_STATE.INIT;
                  }
                  break;
                case ROAP.ROAP_STATE.ERROR:
                  // TODO: resolve error state. Add a signal constant and handle the cleanup
                  value = ROAP.ROAP_STATE.INIT;
                  break;
                case ROAP.ROAP_STATE.GLARE:
                  value = ROAP.ROAP_STATE.WAIT_RX_ANSWER;
                  break;
                default:
                  break;
              }
              return value;
            }
          }
        ],
        methods: {
          shouldStep(roap, meeting, session) {
            const {correlationId} = roap;
            const {seq: sequenceId, messageType, errorType} = roap.msg;
            console.info('Call-RoapHandler: CorrelationID, ', correlationId);
            if (messageType === ERROR && errorType === CONFLICT) {
              throw new Error({reason: 'rollback'});
            }
            if (session.OFFER && messageType === OFFER) {
              session.GLARE_OFFER = roap.msg;
              session.GLARE_OFFER.remote = !!roap.remote;
              console.info(`Its a GLARE condition seq:${sequenceId} new mercury event`);
            }
            else {
              console.info(
                `Save OFFER/ANSWER seq:${sequenceId} new mercury event ${messageType}local state: ${JSON.stringify(
                  session.state.state,
                  null,
                  2
                )}`
              );
              session[messageType] = roap.msg;
              session[messageType].remote = !!roap.remote;
            }
        
            if (meeting) {
              if (messageType === OFFER && roap.remote && meeting.shareStatus === REQUESTED) {
                // The peer-connection is waiting for answer but got an offer Reset. Try to
                // send the offer later after you accept the answer
                console.info(
                  `Call-RoapHandler:The peer-connection has changed before sending the request:${sequenceId}`
                );
                return false;
              }
            }
        
            // Assuming the mercury event has come first before the response for the event
            // we have to wait for the response and trigger the ROAP request later on
            if (meeting && (!meeting.mediaPeerConnection && !meeting.screenPeerConnection) && messageType === ANSWER) {
              config.console.info(
                `Call-RoapHandler: Got RemoteSdp Mercury event before \`/participants\` response correlationId: ${correlationId}`
              );
              return false;
            }
        
            config.console.info('Call-RoapHandler: success save proceeding with transition, ', roap.msg);
        
            return true;
          },
          onAfterStep(transition, signal, meeting, session) {
            console.log(`roap:state#onAfterStep->${transition.event} fired! State changed from '${transition.from}' to '${transition.to}' with transition '${transition.transition}''.`);
          }
        }
    });
    return new RoapState();
  }
  /* eslint-enable */
};

export default RoapStateMachine;
