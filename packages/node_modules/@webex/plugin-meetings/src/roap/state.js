import StateMachine from 'javascript-state-machine';

import {ROAP, OFFER, ANSWER, REQUESTED} from '../constants';

const shouldStep = (roap, meeting) => {
  const {messageType} = roap.msg;
  if (meeting) {
    if (messageType === OFFER && roap.remote && meeting.shareStatus === REQUESTED) {
      // The peer-connection is waiting for answer but got an offer Reset. Try to
      // send the offer later after you accept the answer
      return false;
    }
    // Assuming the mercury event has come first before the response for the event
    // we have to wait for the response and trigger the ROAP request later on
    if ((!meeting.mediaPeerConnection && !meeting.screenPeerConnection) && messageType === ANSWER) {
      return false;
    }
  }
  console.info('Call-RoapHandler: success save proceeding with transition, ', roap.msg);
  return true;
};

const handleTransition = (value, signal, meeting) => {
  switch (value) {
    case ROAP.ROAP_STATE.INIT:
      if (signal === ROAP.ROAP_SIGNAL.RX_OFFER) {
        value = ROAP.ROAP_STATE.WAIT_TX_ANSWER;
      }
      else if (signal === ROAP.ROAP_SIGNAL.TX_OFFER) {
        value = ROAP.ROAP_STATE.WAIT_RX_ANSWER;
      }
      break;
    case ROAP.ROAP_STATE.WAIT_RX_OFFER:
      break;
    case ROAP.ROAP_STATE.WAIT_RX_ANSWER:
      if (signal === ROAP.ROAP_SIGNAL.RX_ANSWER) {
        // There is a race condition where the /call response comes after mercury event from the server
        // As mercury sends roap event if it didnt get back a response. We can send the roap ok after that
        if (meeting.mediaId) {
          value = ROAP.ROAP_STATE.WAIT_TX_OK;
        }
        else {
          console.error('Call-RoapHandler#Race Condition no mediaId');
        }
      }
      else if (signal === ROAP.ROAP_SIGNAL.RX_OFFER) {
        value = ROAP.ROAP_STATE.GLARE;
      }
      break;
    case ROAP.ROAP_STATE.WAIT_TX_OFFER:
      break;
    case ROAP.ROAP_STATE.WAIT_TX_ANSWER:
      if (signal === ROAP.ROAP_SIGNAL.TX_ANSWER) {
        value = ROAP.ROAP_STATE.WAIT_RX_OK;
      }
      break;
    case ROAP.ROAP_STATE.WAIT_TX_OK:
      if (signal === ROAP.ROAP_SIGNAL.TX_OK) {
        value = ROAP.ROAP_STATE.INIT;
      }
      break;
    case ROAP.ROAP_STATE.WAIT_RX_OK:
      if (signal === ROAP.ROAP_SIGNAL.RX_OK) {
        value = ROAP.ROAP_STATE.INIT;
      }
      break;
    case ROAP.ROAP_STATE.ERROR:
      // TODO: resolve error state. Add a signal constant and handle the cleanup
      value = ROAP.ROAP_STATE.INIT;
      break;
    case ROAP.ROAP_STATE.GLARE:
      value = ROAP.ROAP_STATE.WAIT_RX_ANSWER;
      break;
    default:
      break;
  }
  return value;
};

const RoapStateMachine = {

  createState() {
    let RoapState = StateMachine.factory({
      init: ROAP.ROAP_STATE.INIT,
      transitions: [
        {
          name: ROAP.ROAP_TRANSITIONS.STEP,
          from: '*',
          to: function (signal, meeting, roap) {
            const value = this.state;
            if (!shouldStep(roap, meeting)) {
              return value;
            }
            return handleTransition(value, signal, meeting);
          }
        }
      ],
      methods: {
        onAfterStep(transition) {
          console.log(`roap:state#onAfterStep->${transition.event} fired! State changed from '${transition.from}' to '${transition.to}' with transition '${transition.transition}''.`);
        }
      }
    });
    return new RoapState();
  }
};

export default RoapStateMachine;
