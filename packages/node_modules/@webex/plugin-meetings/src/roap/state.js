/* eslint require-jsdoc:0 */
/* globals window */
import {StatelessSparkPlugin} from '@ciscospark/spark-core';
import Promise from 'bluebird';

import MeetingCollection from '../meetings/collection';
import Events from '../events';
import {ROAP, EVENTS, SDP} from '../constants';
import PeerConnectionManager from '../peer-connection-manager';
import RoapUtil from '../roap/util';
import RoapCollection from '../roap/collection';

const config = window;

export default class RoapState extends StatelessSparkPlugin {
  start() {
    return Promise.try(() => {
      this.spark.internal.mercury.on(ROAP.ROAP_MERCURY, (result) => {
        const msg = result.data.message;
        const {correlationId} = result.data;
        config.console.info(`Call-Mercury->-App: receives Roap Message [${JSON.stringify(msg, null, 2)}]`);
        this.submit({
          type: ROAP.RECEIVE_ROAP_MSG,
          msg,
          correlationId
        });
      });
    });
  }

  performState(session, meeting) {
    const mediaOffer = meeting.mediaPeerConnection && meeting.mediaPeerConnection.signalingState === SDP.HAVE_LOCAL_OFFER;
    const screenOffer = meeting.screenPeerConnection && meeting.screenPeerConnection.signalingState === SDP.HAVE_LOCAL_OFFER;

    switch (session.state.state) {
      // case ROAP.ROAP_STATE.INIT:
      // case ROAP.ROAP_STATE.WAIT_RX_OFFER:
      // case ROAP.ROAP_STATE.WAIT_RX_ANSWER:
      // case ROAP.ROAP_STATE.WAIT_RX_OK:

      // TODO: default audio and video , change later
      case ROAP.ROAP_STATE.WAIT_TX_ANSWER:
        // TODO: sometime the you get an answer while you are creating an offer so SKIP
        // Server will send the mercury event comes back
        if (mediaOffer || screenOffer) {
          return;
        }
        PeerConnectionManager.updatePeerConnection({
          offerSdp: session.OFFER.sdps,
          pc: meeting.mediaPeerConnection,
          screenPeerConnection: meeting.screenPeerConnection,
          offerToReceiveAudio: true,
          offerToReceiveVideo: true
        }).then((answerSdps) => {
          Events.emit(EVENTS.ROAP_ANSWER, {
            locusId: meeting.locusId,
            locusSelfId: meeting.locus.self.id,
            mediaId: meeting.mediaId,
            sdps: answerSdps,
            roapSeq: session.OFFER.seq,
            correlationId: meeting.correlationId
          });
        });
        break;
      case ROAP.ROAP_STATE.WAIT_TX_OK:
        RoapUtil.setRemoteDescription(meeting, session).then((res) => {
          Events.emit(EVENTS.ROAP_OK, res);
        });
        break;
      // case ROAP.ROAP_STATE.IDLE_LOCAL_OFFER:
      case ROAP.ROAP_STATE.ERROR:
        config.console.error('Call-RoapHandler#ERROR state=error', session);
        break;
      case this.state.state === ROAP.ROAP_STATE.GLARE:
        session.GLARE_OFFER.tieBreaker = session.GLARE_OFFER.tieBreaker || 0;
        session.OFFER.tieBreaker = session.OFFER.tieBreaker || 0;
        config.console.error('Resolve the GLARE condition');
        if (session.GLARE_OFFER.tieBreaker < session.OFFER.tieBreaker) {
          // 2
          config.console.error('local offer wins');
        }
        else {
          config.console.error('remote offer wins', session);
        }
        session.state.step(ROAP.ROAP_SIGNAL.GLARE_RESOLVED, meeting);
        this.performState(session, meeting);
        break;
      default:
        break;
    }
  }

  submit(action) {
    const {correlationId} = action;
    const session = RoapCollection.getSessionSequence(correlationId, action.seq || action.msg.seq);
    const meeting = MeetingCollection.get(correlationId);
    let signal;

    switch (action.type) {
      case ROAP.RECEIVE_ROAP_MSG:
        // TODO: handle incomplete sequences

        if (!meeting) {
          // There should be a meeting object for each roap call associated
          config.console.error('Call-RoapHandler#RECEIVE_ROAP_MSG: should always have meeting object on roap event');
          break;
        }
        action.remote = true;
        
        try {
          if (session && session.state && session.state.shouldStep(action, meeting, session)) {
            signal = ROAP.ROAP_SIGNAL[`RX_${action.msg.messageType}`];
            session.state.step(signal, meeting);
            this.performState(session, meeting);
          }
        }
        catch (error) {
          if (error.reason === 'rollback') {
            PeerConnectionManager.rollBackLocalDescription({mediaPeerConnection: meeting.mediaPeerConnection})
              .then(() => {
                config.console.info('Delete the sequence data ', action.msg.seq);
                if (meeting) {
                  config.console.info('emitting the callStore changes');
                }
                RoapCollection.deleteSessionSequence(correlationId, action.msg.seq);
              })
              .catch((err) => {
                config.console.info('Cannot reset the peer connection', err);
              });
          }
        }
        break;

      case ROAP.SEND_ROAP_MSG:
        // TODO: handle incomplete sequences
        if (!meeting) {
          // There should be a meeting object for each roap call associated
          config.console.error('Call-RoapHandler#SEND_ROAP_MSG: should always have meeting object on roap event');
          break;
        }
        action.local = true;
        try {
          if (session && session.state && session.state.shouldStep(action, meeting, session)) {
            signal = ROAP.ROAP_SIGNAL[`TX_${action.msg.messageType}`];
            session.state.step(signal, meeting);
            this.performState(session, meeting);
          }
        }
        catch (error) {
          if (error.reason === 'rollback') {
            PeerConnectionManager.rollBackLocalDescription({mediaPeerConnection: meeting.mediaPeerConnection})
              .then(() => {
                config.console.info('Delete the sequence data ', action.msg.seq);
                if (meeting) {
                  config.console.info('emitting the callStore changes');
                }
                RoapCollection.deleteSessionSequence(correlationId, action.msg.seq);
              })
              .catch((err) => {
                config.console.info('Cannot reset the peer connection', err);
              });
          }
        }
        break;

      case ROAP.SEND_ROAP_MSG_SUCCESS:
        if (!meeting) {
          // There should be a meeting object for each roap call associated
          config.console.error('Call-this#SEND_ROAP_MSG_SUCCESS: should always have meeting object on roap event');
          break;
        }
        // This means we got and answer and waiting for 200 ok for /participants
        if (RoapCollection.getSessionSequence(correlationId, action.seq).ANSWER) {
          signal = ROAP.ROAP_SIGNAL.RX_ANSWER;
          // NOTE: When server send back an answer via mercury the
          // remote SDP is already saved sent and ok message is sent back
          // We dont have to indicate the roapHandler about the RX_ANSWER via SEND_ROAP_MSG_SUCCESS
          // RoapHandler.transition(signal, session, meeting);
        }
        break;

      case 'RECEIVE_CALL_LEAVE':
        RoapCollection.deleteSession(correlationId);
        config.console.info('Call-this#RECEIVE_CALL_LEAVE: cleaning up the RoapHandler', correlationId);
        break;
      case ROAP.RESET_ROAP_STATE:
        RoapCollection.deleteSessionSequence(correlationId, action.msg.seq);
        config.console.info('Call-RoapHandler#RESET_ROAP_STATE: resetting the RoapHandler state', action.msg.seq);
        break;
      default:
        return true;
    }
    config.console.log('Call-RoapHandler: Event %s ,  %s , %s', action.type, correlationId, action.msg);
    return true;
  }
}
