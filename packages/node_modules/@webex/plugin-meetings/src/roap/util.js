import PeerConnectionManager from '../peer-connection-manager';
import {_ANSWER_, ERROR, CONFLICT, ROAP, SDP} from '../constants';

const RoapUtil = {};

RoapUtil.shouldHandleMedia = (meeting) => {
  const mediaOffer = meeting.mediaPeerConnection && meeting.mediaPeerConnection.signalingState === SDP.HAVE_LOCAL_OFFER;
  const screenOffer = meeting.screenPeerConnection && meeting.screenPeerConnection.signalingState === SDP.HAVE_LOCAL_OFFER;
  if (mediaOffer || screenOffer) {
    return false;
  }
  return true;
};

RoapUtil.handleError = (pc) => PeerConnectionManager.rollBackLocalDescription({mediaPeerConnection: pc})
  .then(() => Promise.resolve(true))
  .catch((err) => Promise.reject(err));

RoapUtil.findError = (messageType, errorType, type) =>
  (type === ROAP.RECEIVE_ROAP_MSG || type === ROAP.SEND_ROAP_MSG) && messageType === ERROR && errorType === CONFLICT;

RoapUtil.ensureMeeting = (meeting, type) => {
  if (type === ROAP.RECEIVE_ROAP_MSG || type === ROAP.SEND_ROAP_MSG || type === ROAP.SEND_ROAP_MSG_SUCCESS) {
    if (!meeting) {
      return false;
    }
  }
  return true;
};

RoapUtil.updatePeerConnection = (meeting, session) => {
  return PeerConnectionManager.updatePeerConnection({
    offerSdp: session.OFFER.sdps,
    pc: meeting.mediaPeerConnection,
    screenPeerConnection: meeting.screenPeerConnection,
    offerToReceiveAudio: true,
    offerToReceiveVideo: true
  });
};

RoapUtil.setRemoteDescription = (meeting, session) => {
  console.info('Call-RoapHandler: Transmite WAIT_TX_OK', meeting.correlationId);
  if (!(meeting && (meeting.mediaPeerConnection || meeting.screenPeerConnection))) {
    console.error('Call-RoapHandler: DANGER no media or screen peer connection', meeting.correlationId);
    return Promise.reject();
  }
  let promise;
  if (meeting.mediaPeerConnection && meeting.screenPeerConnection) {
    promise = Promise.all([
      PeerConnectionManager.setRemoteSessionDetails(
        meeting.mediaPeerConnection,
        _ANSWER_,
        session.ANSWER.sdps[0],
        meeting.clientIdentifiers
      ),
      PeerConnectionManager.setRemoteSessionDetails(
        meeting.screenPeerConnection,
        _ANSWER_,
        session.ANSWER.sdps[1],
        meeting.clientIdentifiers
      )
    ]);
  }
  else if (meeting.screenPeerConnection) {
    promise = PeerConnectionManager.setRemoteSessionDetails(
      meeting.screenPeerConnection,
      _ANSWER_,
      session.ANSWER.sdps[0],
      meeting.clientIdentifiers
    );
  }
  return promise
    .then(() => {
      console.info('Call-RoapHandler: setRemote Description successfull', meeting.correlationId);
      return Promise.resolve({
        seq: session.ANSWER.seq,
        locusId: meeting.locusId,
        locusSelfId: meeting.locus.self.id,
        mediaId: meeting.mediaId,
        correlationId: meeting.correlationId
      });
    })
    .catch((err) => {
      console.error('Call-RoapHandler: Error setting remote and sending Roap Message', err);
      return Promise.reject();
    });
};

export default RoapUtil;
