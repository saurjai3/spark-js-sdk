/* eslint-disable require-jsdoc */

import uuid from 'uuid';
import {StatelessSparkPlugin} from '@ciscospark/spark-core';
import StateMachine from 'javascript-state-machine';

import Roap from '../roap/index';
import Media from '../media';
import PeerConnectionManager from '../peer-connection-manager';
import MeetingRequest from '../meeting/request';
import MeetingUtil from '../meeting/util';
import {MEETING_STATE_MACHINE} from '../constants';

/**
 * @export
 * @class Meeting
 */
export default class Meeting extends StatelessSparkPlugin {
  // /**
  //  * Create an instance of Meeting
  //  *
  //  * @param {string} options.id
  //  * @param {string} options.spaceID
  //  * @param {array} options.members
  //  * @param {object} options.peerConnections
  //  * @param {object} options.health
  //  * @param {string} options.type
  //  * @param {string} options.direction
  //  * @param {object} options.pairedDevice
  //  * @param {ISOString} options.startTime
  //  * @param {ISOString} options.endTime
  //  * @memberof Meeting
  //  */
  constructor(attrs, options) {
    // Pass the spark reference to the StatelessSparkPlugin
    // constructor as parent instead of in the options
    super({}, options);

    this.id = uuid.v4();
    this.userId = attrs.userId;
    this.resource = attrs.resource;
    this.sipUri = attrs.sipUri;
    this.deviceUrl = attrs.deviceUrl;
    this.videoMuted = false;
    this.audioMuted = false;
    this.roapSeq = 0;
    this.meetingInfo = attrs.meetingInfo || {};

    this.meetingRequest = new MeetingRequest({}, options);
    this.roap = new Roap({}, options);

    this.state = new StateMachine({
      init: MEETING_STATE_MACHINE.STATES.IDLE,
      transitions: [
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.START,
          from: MEETING_STATE_MACHINE.STATES.IDLE,
          to: MEETING_STATE_MACHINE.STATES.ON_GOING
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.START,
          from: MEETING_STATE_MACHINE.STATES.IDLE,
          to: MEETING_STATE_MACHINE.STATES.INCOMING
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.JOIN,
          from: MEETING_STATE_MACHINE.STATES.IDLE,
          to: MEETING_STATE_MACHINE.STATES.DIALING
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.JOIN,
          from: MEETING_STATE_MACHINE.STATES.ON_GOING,
          to: MEETING_STATE_MACHINE.STATES.DIALING
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.JOIN,
          from: MEETING_STATE_MACHINE.STATES.INCOMING,
          to: MEETING_STATE_MACHINE.STATES.DIALING
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.LOCAL,
          from: MEETING_STATE_MACHINE.STATES.DIALING,
          to: MEETING_STATE_MACHINE.STATES.CONNECTING_MEDIA_LOCAL
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.CONNECT,
          from: MEETING_STATE_MACHINE.STATES.CONNECTING_MEDIA_LOCAL,
          to: MEETING_STATE_MACHINE.STATES.CONNECTING_MEDIA_REMOTE
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.ESTABLISH,
          from: MEETING_STATE_MACHINE.STATES.CONNECTING_MEDIA_REMOTE,
          to: MEETING_STATE_MACHINE.STATES.ESTABLISHED_MEDIA
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.LEAVE,
          from: MEETING_STATE_MACHINE.STATES.ESTABLISHED_MEDIA,
          to: MEETING_STATE_MACHINE.STATES.TERMINATING
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.END,
          from: MEETING_STATE_MACHINE.STATES.TERMINATING,
          to: MEETING_STATE_MACHINE.STATES.ENDED
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.CLEAN,
          from: MEETING_STATE_MACHINE.STATES.ENDED,
          to: MEETING_STATE_MACHINE.STATES.IDLE
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.CLEAN,
          from: MEETING_STATE_MACHINE.STATES.ERROR,
          to: MEETING_STATE_MACHINE.STATES.IDLE
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.ERROR,
          from: '*',
          to: MEETING_STATE_MACHINE.STATES.ERROR
        }
      ],
      methods: {
        // TODO more dynamic logger functions
        onInit: (transition) => {
          console.log(
            `Meeting:index#onInit->${transition.event} fired! State changed from '${transition.from}' to '${
              transition.to
            }' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`
          );
        },
        onError: (transition) => {
          console.log(
            `Meeting:index#onError->${transition.event} fired! State changed from '${transition.from}' to '${
              transition.to
            }' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`
          );
        },
        onClean: (transition) => {
          console.log(
            `Meeting:index#onClean->${transition.event} fired! State changed from '${transition.from}' to '${
              transition.to
            }' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`
          );
        },
        onJoin: (transition) => {
          console.log(
            `Meeting:index#onJoin->${transition.event} fired! State changed from '${transition.from}' to '${
              transition.to
            }' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`
          );
        },
        onLocal: (transition) => {
          console.log(
            `Meeting:index#onLocal->${transition.event} fired! State changed from '${transition.from}' to '${
              transition.to
            }' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`
          );
        },
        onConnect: (transition) => {
          console.log(
            `Meeting:index#onConnect->${transition.event} fired! State changed from '${transition.from}' to '${
              transition.to
            }' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`
          );
        },
        onEstablish: (transition) => {
          console.log(
            `Meeting:index#onEstablish->${transition.event} fired! State changed from '${transition.from}' to '${
              transition.to
            }' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`
          );
        }
        // TODO add all on<Transition> methods
        // TODO potentially use the state transition methods to actually initiate the steps, rather than just track state
        /* TODO
      onInvalidTransition: (transition, from, to) => { // TODO
        if (transition && from && to) {
          throw new Error('transition not allowed from that state');
        }
      },
      onPendingTransition: (transition, from, to) => { // TODO
        if (transition && from && to) {
          throw new Error('transition already in progress');
        }
      } */
      }
    });
  }

  setMeetingInfo(meetingInfo) {
    // MeetingInfo will be undefined for 1:1 calls
    if (meetingInfo) {
      this.convoId = this.meetingInfo.convoId;
      this.locusUrl = this.meetingInfo.locusUrl;
      this.sipUri = this.meetingInfo.sipMeetingUri;
    }
  }

  setRoapSeq(seq) {
    this.roapSeq = seq;
  }

  setLocusJoin(locus) {
    this.locus = locus.locus;
    this.mediaConnections = locus.mediaConnections;
    this.locusUrl = locus.locusUrl;
    this.locusId = locus.locusId;
    this.selfId = locus.selfId;
    this.mediaId = locus.mediaId;
  }

  setRemoteStreams(pc) {
    // Receiving remote media streams
    pc.ontrack = (event) => {
      [this.mediaStream, this.localMediaStream] = event.streams;
      document.getElementById('remotevideo').srcObject = this.mediaStream;
    };
  }

  setScreenStreams(pc) {
    // Receive remote screen streams TODO
    pc.ontrack = (event) => {
      [this.screenStream] = event.streams;
      document.getElementById('screenvideo').srcObject = this.screenStream;
    };
  }

  setLocalVideo(stream) {
    // get 0th
    [document.getElementById('localvideo').srcObject] = stream;
  }

  setPeerConnections(mediaPeerConnection, screenPeerConnection) {
    // Cache these locally for later use
    this.mediaPeerConnection = mediaPeerConnection;
    this.screenPeerConnection = screenPeerConnection;
  }

  setCorrelationId(id) {
    this.correlationId = id;
  }

  /**
   *
   * Specify joining via audio (option: pstn), video, screenshare
   * @exports
   * @param {object} [options={ PairedDevice, Password }]
   * @returns {Promise}
   * @memberof Meeting
   */
  join(options) {
    const {mediaDirection} = options;
    this.setCorrelationId(this.id);
    this.state.join();
    return MeetingUtil.joinMeeting(this)
      .then((response) => {
        this.setLocusJoin(response);
        this.state.local();
        return Media.getLocalMedia({
          sendAudio: mediaDirection.sendAudio,
          sendVideo: mediaDirection.sendVideo,
          sendShare: mediaDirection.sendShare
        });
      })
      .catch((err) => {
        console.log('Meeting:index#join --> Error joining the call on getLocalMedia, ', err);
        throw err;
      })
      .then((streams) => {
        this.state.connect();
        this.setLocalVideo(streams);
        return Media.addMedia(mediaDirection, PeerConnectionManager, streams);
      })
      .catch((err) => {
        console.log('Meeting:index#join --> Error joining the call on addMedia, ', err);
        throw err;
      })
      .then(([mediaPeerConnection, screenPeerConnection]) => {
        screenPeerConnection = PeerConnectionManager.setContentSlides(screenPeerConnection);
        this.setPeerConnections(mediaPeerConnection, screenPeerConnection);
        this.setRemoteStreams(this.mediaPeerConnection);
        this.setScreenStreams(this.screenPeerConnection);
        return this.roap.roapState.start();
      })
      .catch((err) => {
        console.log('Meeting:index#join --> Error joining the call on roap initialization, ', err);
        throw err;
      })
      .then(() =>
        this.roap
          .sendRoapMediaRequest({
            sdps: [this.mediaPeerConnection.sdp, this.screenPeerConnection.sdp],
            roapSeq: this.roapSeq,
            meeting: this // or can pass meeting ID
          })
          .then(() => {
            this.state.establish();
            return Promise.resolve();
          })
          .catch((err) => {
            console.log('Meeting:index#join --> Error joining the call on send roap media request, ', err);
            throw err;
          }));
  }

  /**
   *
   * Move this meeting to a given device
   * only possible if you are paired with the given device
   * @param {string} deviceID
   * @returns {Promise}
   * @memberof Meeting
   */
  moveToDevice(deviceID) {
    return new Promise((resolve) => resolve(deviceID));
  }

  /**
   *
   * Move this meeting back to the current client device, e.g., personal laptop.
   * @returns {Promise}
   * @memberof Meeting
   */
  moveToClient() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Update the audio options of this meeting
   * @param {object} [options]
   * @param {string} status
   * @returns {Promise}
   * @memberof Meeting
   */
  updateAudio(options = {}, status) {
    return new Promise((resolve) => resolve(options, status));
  }

  /**
   *
   * Update the video option of this meeting
   * @param {string} status
   * @returns {Promise}
   * @memberof Meeting
   */
  updateVideo(status) {
    return new Promise((resolve) => resolve(status));
  }

  /**
   *
   * Update screen sharing preference of this meeting
   * @param {string} shareType
   * @returns {Promise}
   * @memberof Meeting
   */
  updateShare(shareType) {
    return new Promise((resolve) => resolve(shareType));
  }

  /**
   *
   * Alias of updateShare
   * @param {*} args
   * @returns {updateShare}
   * @memberof Meeting
   */
  share(...args) {
    this.updateShare(args);
  }

  /**
   *
   * Leave the current meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  leave() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Decline this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  decline() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Send this meeting to the phone system
   * @returns {Promise}
   * @memberof Meeting
   */
  sendDtmf() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Get statistics of the current meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  getStats() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Lock this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  lock() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Unlock this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  unlock() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Intiate a recording of this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  startRecording() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * End the recording of this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  stopRecording() {
    return new Promise((resolve) => resolve({}));
  }
}
