/* globals window */
import uuid from 'uuid';
import StateMachine from 'javascript-state-machine';

import Media from '../media';
import PeerConnectionManager from '../peer-connection-manager';
import RoapInterface from '../roap/roap-interface';
import RoapAdapter from '../roap/roap-adapter';
import MeetingRequest from '../meeting/request';
import MeetingUtil from '../meeting/util';
import {SDP, MEETING_STATE_MACHINE} from '../constants';

/**
  * Events to emit
  * ==============
  * - leave
  * - join
  * - end
  * - meeting.metrics {
  *   - media
  *   - MQE
  *   - callAnalyzer
  *   - meetingEndMetrics?
  * }
  * - statusChange {
  *   - status, e.g., leaving, left, reason
  * }
  * - typeChange {
  *   - type
      - reason
  * }
  *
  * @export
  * @class Meeting
  */
export default class Meeting {
  /**
   * Create an instance of Meeting
   *
   * @param {object} options
   * //
   * @param {string} options.id
   * @param {string} options.spaceID
   * @param {array} options.members
   * @param {object} options.peerConnections
   * @param {object} options.health
   * @param {string} options.type
   * @param {string} options.direction
   * @param {object} options.pairedDevice
   * @param {ISOString} options.startTime
   * @param {ISOString} options.endTime
   * //
   * @memberof Meeting
   */
  constructor(options) {
    this.id = uuid.v4();
    this.spark = options.spark;
    this.meetingInfo = options.meetingInfo;
    // THe passed in destination can have many ways of calling
    // sipUrl , convo Id etc we want to refer the meeting with same Ids
    // TODO: check for the destination and convert it into a sip uri if possible
    this.updateMeetingInfo(this.meetingInfo);
    this.sipUri = this.sipUri || options.destination;
    this.userId = this.spark.internal.device.userId;
    this.deviceUrl = this.spark.internal.device.url;
    this.resource = options.resourceId; // Can be a object, resource or self object
    this.roapSeq = 0;
    this.videoMuted = false;
    this.audioMuted = false;
    this.state = new StateMachine({
      init: MEETING_STATE_MACHINE.states.IDLE,
      transitions: [
        {
          name: MEETING_STATE_MACHINE.transitions.START,
          from: MEETING_STATE_MACHINE.states.IDLE,
          to: MEETING_STATE_MACHINE.states.ON_GOING
        },
        {
          name: MEETING_STATE_MACHINE.transitions.START,
          from: MEETING_STATE_MACHINE.states.IDLE,
          to: MEETING_STATE_MACHINE.states.INCOMING
        },
        {
          name: MEETING_STATE_MACHINE.transitions.JOIN,
          from: MEETING_STATE_MACHINE.states.IDLE,
          to: MEETING_STATE_MACHINE.states.DIALING
        },
        {
          name: MEETING_STATE_MACHINE.transitions.JOIN,
          from: MEETING_STATE_MACHINE.states.ON_GOING,
          to: MEETING_STATE_MACHINE.states.DIALING
        },
        {
          name: MEETING_STATE_MACHINE.transitions.JOIN,
          from: MEETING_STATE_MACHINE.states.INCOMING,
          to: MEETING_STATE_MACHINE.states.DIALING
        },
        {
          name: MEETING_STATE_MACHINE.transitions.CONNECT,
          from: MEETING_STATE_MACHINE.states.DIALING,
          to: MEETING_STATE_MACHINE.states.CONNECTING_MEDIA
        },
        {
          name: MEETING_STATE_MACHINE.transitions.ESTABLISH,
          from: MEETING_STATE_MACHINE.states.CONNECTING_MEDIA,
          to: MEETING_STATE_MACHINE.states.ESTABLISHED_MEDIA
        },
        {
          name: MEETING_STATE_MACHINE.transitions.LEAVE,
          from: MEETING_STATE_MACHINE.states.ESTABLISHED_MEDIA,
          to: MEETING_STATE_MACHINE.states.TERMINATING
        },
        {
          name: MEETING_STATE_MACHINE.transitions.END,
          from: MEETING_STATE_MACHINE.states.TERMINATING,
          to: MEETING_STATE_MACHINE.states.ENDED
        },
        {
          name: MEETING_STATE_MACHINE.transitions.CLEAN,
          from: MEETING_STATE_MACHINE.states.ENDED,
          to: MEETING_STATE_MACHINE.states.IDLE
        },
        {
          name: MEETING_STATE_MACHINE.transitions.CLEAN,
          from: MEETING_STATE_MACHINE.states.ERROR,
          to: MEETING_STATE_MACHINE.states.IDLE
        },
        {
          name: MEETING_STATE_MACHINE.transitions.ERROR,
          from: '*',
          to: MEETING_STATE_MACHINE.states.ERROR
        }
      ],
      methods: {
        // TODO more dynamic logger functions
        onInit: (transition) => {
          console.log(`Meeting:index#onInit->${transition.event} fired! State changed from '${transition.from}' to '${transition.to}' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`);
        },
        onError: (transition) => {
          console.log(`Meeting:index#onError->${transition.event} fired! State changed from '${transition.from}' to '${transition.to}' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`);
        },
        onClean: (transition) => {
          console.log(`Meeting:index#onClean->${transition.event} fired! State changed from '${transition.from}' to '${transition.to}' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`);
        },
        onJoin: (transition) => {
          console.log(`Meeting:index#onClean->${transition.event} fired! State changed from '${transition.from}' to '${transition.to}' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`);
        },
        onConnect: (transition) => {
          console.log(`Meeting:index#onClean->${transition.event} fired! State changed from '${transition.from}' to '${transition.to}' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`);
        },
        onEstablish: (transition) => {
          console.log(`Meeting:index#onClean->${transition.event} fired! State changed from '${transition.from}' to '${transition.to}' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`);
        }
        // TODO add all on<Transition> methods
        /* TODO
        onInvalidTransition: (transition, from, to) => { // TODO
          if (transition && from && to) {
            throw new Error('transition not allowed from that state');
          }
        },
        onPendingTransition: (transition, from, to) => { // TODO
          if (transition && from && to) {
            throw new Error('transition already in progress');
          }
        } */
      }
    });

    this.request = new MeetingRequest({spark: this.spark, logger: this.logger});

    window.spark = this.spark; // TODO remove this after we refactor all the ROAP circular dependencies

    // this.peerConnectionManager = new PeerConnectionManager(config);
    // this.roapInterface = new RoapInterface();
    // this.stateMachine = new stateMachine(); //constants

    // this.memebers = members;
    // this.peerConnections = peerConnections;
    // this.health = health;
    // this.type = type;
    // this.direction = direction;
    // this.pairedDevice = pairedDevice;
    // this.startTime = startTime || new Date().toISOString();
    // this.endTime = endTime || new Date().toISOString();
  }

  updateMeetingInfo(meetingInfo) {
    // MeetingInfo will be undefined for 1:1 calls
    if (meetingInfo) {
      this.convoId = this.meetingInfo.convoId;
      this.locusUrl = this.meetingInfo.locusUrl;
      this.sipUri = this.meetingInfo.sipMeetingUri;
    }
  }

  joinMeeting() {
    // TODO: check if the meeting is in JOINING state
    // if JOining state termintate the request as user might click multiple times
    this.correlationId = this.id;
    return this.request
      .joinMeeting({
        sipUri: this.sipUri,
        deviceUrl: this.deviceUrl,
        locusUrl: this.locusUrl,
        correlationId: this.id
      })
      .then((res) => {
        // TODO: was thinking to have one function for parsing
        // all updates will give a locus object and we just need to
        // update the existing locus object and send events to the UI
        const locusResponse = MeetingUtil.parseLocus(res);
        this.locus = locusResponse.locus;
        this.mediaConnections = locusResponse.mediaConnections;
        this.locusUrl = locusResponse.locusUrl;
        this.locusId = locusResponse.locusId;
        this.selfId = locusResponse.selfId;
        this.mediaId = locusResponse.mediaId;
      })
      .catch((err) => {
        console.log('ERROR JOINING CALL', err);
      });
  }

  updateRoapSeq(seq) {
    this.roapSeq = seq;
  }

  addMedia(audioVideo, screen) {
    const promises = [];
    this.mediaDirection = {
      receiveAudio: true,
      receiveVideo: true
    };
    [document.getElementById('localvideo').srcObject] = audioVideo;
    if (this.mediaDirection.receiveVideo || this.mediaDirection.receiveAudio) {
      promises.push(
        PeerConnectionManager.createOffer({
          receiveAudio: this.mediaDirection.receiveAudio,
          receiveVideo: this.mediaDirection.receiveVideo,
          // After you get the localStream
          audioVideo
        })
      );

      promises.push(
        PeerConnectionManager.createOffer({
          // its for screen sharing but can change in future when user wants just share with audio
          receiveAudio: false,
          receiveVideo: this.mediaDirection.receiveVideo,
          // After you get the localStream
          streams: screen
        })
      );
    }
    return Promise.all(promises);
  }

  getLocalMedia(options) {
    const {sendAudio, sendVideo, sendShare} = options;
    return Promise.try(() =>
      /* Media.getScreenShare(sendShare))
      .then((screenConstraints) => Media.getMedia(false, screenConstraints))
      .then((screen) => */ Media.getMedia(
        sendAudio,
        sendVideo
      ).then((media) => [media, undefined])); // TODO define undefined as screen pc
  }

  /**
   *
   * Specify joining via audio (option: pstn), video, screenshare
   * @exports
   * @param {object} [options={ PairedDevice, Password }]
   * @returns {Promise}
   * @memberof Meeting
   */
  join(options) {
    // let {mediaDirection} = options;

    const mediaDirection = {
      sendAudio: true,
      sendVideo: true,
      receiveAudio: true,
      receiveVideo: true,
      pstn: false,
      sendShare: false,
      receiveShare: false
    };
    this.state.join();
    return this.joinMeeting()
      .then(() =>
        this.getLocalMedia({
          sendAudio: mediaDirection.sendAudio,
          sendVideo: mediaDirection.sendVideo,
          sendShare: mediaDirection.sendShare
        }))
      .then((streams) => {
        this.state.connect();
        return this.addMedia(streams);
      })
      .then(([mediaPeerConnection, screenPeerConnection]) => {
        if (screenPeerConnection && screenPeerConnection.sdp) {
          screenPeerConnection.sdp += `${SDP.A_CONTENT_SLIDES}${SDP.CARRIAGE_RETURN}`;
        }

        // Cache these locally for later use
        this.mediaPeerConnection = mediaPeerConnection;
        this.screenPeerConnection = screenPeerConnection;

        // Receiving remote media streams
        this.mediaPeerConnection.ontrack = (event) => {
          [this.mediaStream, this.localMediaStream] = event.streams;
          document.getElementById('remotevideo').srcObject = this.mediaStream;
        };
        // add meeting screen streams

        // Receive remote screen streams TODO
        this.screenPeerConnection.ontrack = (event) => {
          [this.screenStream] = event.streams;
          document.getElementById('screenvideo').srcObject = this.screenStream;
        };

        return RoapAdapter.initialize();
      })
      .then(() => {
        RoapInterface.sendRoapMediaRequest({
          sdps: [this.mediaPeerConnection.sdp, this.screenPeerConnection.sdp],
          roapSeq: this.roapSeq,
          meeting: this // or can pass meeting ID
        })
          .then(() => {
            this.state.establish();
            return Promise.resolve();
          });
      });
  }

  /**
   *
   * Move this meeting to a given device
   * only possible if you are paired with the given device
   * @param {string} deviceID
   * @returns {Promise}
   * @memberof Meeting
   */
  moveToDevice(deviceID) {
    return new Promise((resolve) => resolve(deviceID));
  }

  /**
   *
   * Move this meeting back to the current client device, e.g., personal laptop.
   * @returns {Promise}
   * @memberof Meeting
   */
  moveToClient() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Update the audio options of this meeting
   * @param {object} [options]
   * @param {string} status
   * @returns {Promise}
   * @memberof Meeting
   */
  updateAudio(options = {}, status) {
    return new Promise((resolve) => resolve(options, status));
  }

  /**
   *
   * Update the video option of this meeting
   * @param {string} status
   * @returns {Promise}
   * @memberof Meeting
   */
  updateVideo(status) {
    return new Promise((resolve) => resolve(status));
  }

  /**
   *
   * Update screen sharing preference of this meeting
   * @param {string} shareType
   * @returns {Promise}
   * @memberof Meeting
   */
  updateShare(shareType) {
    return new Promise((resolve) => resolve(shareType));
  }

  /**
   *
   * Alias of updateShare
   * @param {*} args
   * @returns {updateShare}
   * @memberof Meeting
   */
  share(...args) {
    this.updateShare(args);
  }

  /**
   *
   * Leave the current meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  leave() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Decline this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  decline() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Send this meeting to the phone system
   * @returns {Promise}
   * @memberof Meeting
   */
  sendDtmf() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Get statistics of the current meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  getStats() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Lock this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  lock() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Unlock this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  unlock() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Intiate a recording of this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  startRecording() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * End the recording of this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  stopRecording() {
    return new Promise((resolve) => resolve({}));
  }
}
