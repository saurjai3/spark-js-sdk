/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {merge, keyBy} from 'lodash';
import {SparkPlugin} from '@ciscospark/spark-core';
import {LYRA_SPACE, UC_CLOUD} from './constants';
import uuid from 'uuid';

const DeviceManager = SparkPlugin.extend({
  namespace: 'DeviceManager',
  _mapOfDevices: {},
  _devicePendingPinChallenge: null,
  _pairedDevice: null,
  _boundSpace: null,

  /**
  * Gets a list of all recent devices associated with the user
  * the device list gets populated from Redis
  * @returns {Promise<Device>}
  */
  listAllDevices() {
    return this.spark.request({
      api: 'wdm',
      resource: 'devices/auxiliary'
    })
      .then((res) => {
        if (!res.body) {
          return Promise.reject();
        }
        return Promise.all(res.body.items.map((device) => {
          if (device.deviceClass === UC_CLOUD) {
            device.id = `${this.spark.internal.device.services.wdmServiceUrl}/${device.id}`;
          }
          return this._decryptDeviceName(device);
        }))
          .then(() => {
            /* eslint-disable consistent-return */
            res.body.items.forEach((device) => {
              if (device.deviceInfo
                && device.deviceInfo.machineType === LYRA_SPACE) {
                return this.spark.internal.lyra.space.get(device.deviceInfo)
                  .catch((err) => {
                    console.error('DeviceManager#listAllDevices: failed to receive device info', err);
                  });
              }
            });
            /* eslint-enable consistent-return */
            this._mapOfDevices = keyBy(res.body.items, 'id');
            return res.body.items;
          });
      })
      .catch((err) => {
        console.error('DeviceManager#listAllDevices: failed to fetch recent devices', err);
      });
  },

  /**
  * Search for a device by name
  * @param {Object} options
  * @param {string} options.searchQuery
  * @returns {Promise<Device>}
  */
  search(options) {
    if (!options || !options.searchQuery) {
      console.error('DeviceManager#search: options.searchQuery is required');
      return Promise.reject(new Error('DeviceManager#search: options.searchQuery is required'));
    }
    return this.spark.internal.search.people({
      searchId: uuid.v4(),
      searchType: 'DEVICE_SEARCH',
      searchEntity: 'device',
      includePeople: false,
      includeRooms: true,
      queryString: options.searchQuery
    })
      .catch((err) => {
        console.error('DeviceManager#search: failed to search a device', err);
      });
  },

  /**
  * Caches the device info and also registers to Redis for subsequent fetches
  * @param {Object} device
  * @param {string} device.id
  * @returns {deviceInfo}
  */
  upsert(device) {
    const deviceId = device.id || device.identity && device.identity.id;
    if (!deviceId) {
      console.error('DeviceManager#upsert: device.id is required');
      return Promise.reject(new Error('DeviceManager#upsert: device.id is required'));
    }
    this._pairedDevice = this._devicePendingPinChallenge;
    this._devicePendingPinChallenge = null;
    // check if the device is already existing, if so then merge else add
    const existingDevice = this._mapOfDevices[deviceId];
    if (existingDevice) {
      // already existing, merge for any new binding information
      merge(existingDevice, device);
      return Promise.resolve(true);
    }
    // new device requested, add to wdm for subsequent retreivals
    return this.spark.request({
      api: 'wdm',
      method: 'PUT',
      resource: `devices/auxiliary/Room/${deviceId}`
    })
      .then((res) => {
        const auxDevice = res.body;
        return this._decryptDeviceName(auxDevice);
      })
      .catch((err) => {
        console.error('DeviceManager#upsert: failed to add/update a device', err);
        return Promise.reject(err);
      });
  },

  /**
  * Retreives device info of a particular device
  * @param {string} token
  * @returns {Promise<deviceInfo>}
  */
  get(token) {
    if (!token) {
      console.error('DeviceManager#get: token is required');
      return Promise.reject(new Error('DeviceManager#get: token is required'));
    }
    let deviceInfo;
    return this.spark.internal.lyra.getAdvertisedEndpoint(token)
      .then((res) => {
        deviceInfo = res;
        return this.spark.internal.lyra.space.get({id: res.advertiser.id});
      })
      .then((result) => {
        // the deviceInfo doesn't have proper displayName, hence update
        // displayName on deviceInfo for search to work
        if (result && result.identity && result.identity.displayName) {
          deviceInfo.advertiser.displayName = result.identity.displayName;
        }
        return deviceInfo;
      })
      .catch((err) => {
        console.error('DeviceManager#get: failed to get device info', err);
        return Promise.reject(err);
      });
  },

  /**
  * Unregisters the device from Redis, will not fetch in subsequent loads,
  * similar to space.deleteBinding()
  * @param {string} deviceId
  * @returns {Promise<deviceInfo>}
  */
  remove(deviceId) {
    if (deviceId) {
      return this.spark.request({
        method: 'delete',
        api: 'wdm',
        resource: `devices/auxiliary/${deviceId}`
      })
        .catch((error) => {
          console.error('DeviceManager#remove: failed to remove the device', error);
          return Promise.reject(error);
        });
    }
    console.error('DeviceManager#remove: deviceId is required');
    return Promise.reject(new Error('DeviceManager#remove: deviceId is required'));
  },

  /**
  * Requests to display PIN on the device
  * @param {object} device
  * @param {object} options
  * @param {object} options.data
  * @returns {Promise<deviceInfo>}
  */
  requestPin(device, options = {}) {
    const deviceId = device.id || device.identity && device.identity.id;
    if (!deviceId) {
      console.error('DeviceManager#requestPin: device.id is required');
      return Promise.reject(new Error('DeviceManager#requestPin: device.id is required'));
    }
    const space = {id: deviceId, url: `/spaces/${deviceId}`};
    return this.spark.internal.lyra.space.get(space)
      .then((dev) => { // check if the space is pinChallenge capable
        if (dev && dev.occupants && dev.occupants.pinChallenge) {
          console.info('DeviceManager#requestPin: space is PIN challenge capable');
          return this.spark.internal.lyra.space.join(space, {
            passType: 'MANUAL',
            verificationInitiation: 'PIN',
            data: options.data
          })
            .then(() => {
              this._devicePendingPinChallenge = dev;
              // return the actual device so that it can be upserted on successful
              // PIN exchange
              return dev;
            });
        }
        // pairs with the space if it's not PIN challenge capable
        console.info('DeviceManager#requestPin: space is not PIN challenge capable, probably already occupied, will still return device info');
        return this.spark.internal.lyra.space.get(space)
          .then(() => Promise.resolve(dev));
      })
      .catch((err) => {
        console.error('DeviceManager#requestPin: device failed PIN challenge request', err);
        return Promise.reject(err);
      });
  },

  /**
  * pairs the device with the user (manual pairing), also adds it to
  * user's recents list for subsequent fetches.
  * similar to space.join()
  * @param {object} options
  * @param {number} options.pin
  * @returns {Promise<deviceInfo>}
  */
  pair(options = {}) {
    if (!options.pin) {
      console.error('DeviceManager#pair: options.pin is required');
      return Promise.reject(new Error('DeviceManager#pair: options.pin is required'));
    }
    if (this._devicePendingPinChallenge) {
      const space = {id: this._devicePendingPinChallenge.identity.id, url: `/spaces/${this._devicePendingPinChallenge.identity.id}`};

      return this.spark.internal.lyra.space.join(space, {
        passType: 'PIN_ANSWER',
        data: options.pin
      })
        .then(() => this.upsert(this._devicePendingPinChallenge))
        .catch((err) => {
          console.error('DeviceManager#pair: incorrect PIN, unable to pair ', err);
          return Promise.reject(err);
        });
    }
    console.error('DeviceManager#pair: no device to pair');
    return Promise.reject(new Error('DeviceManager#pair: no device to pair'));
  },

  /**
  * unpairs the device with the user (manual/ultrasonic pairing), but still
  * keeps in the recents list/does not remove from Redis
  * options.removeAllDevices will remove all associated devices to user
  * similar to space.leave()
  * @param {object} options
  * @param {boolean} options.removeAllDevices
  * @returns {Promise<deviceInfo>}
  */
  unpair(options = {}) {
    if (this._pairedDevice) {
      const space = {url: `/spaces/${this._pairedDevice.identity.id}`};
      return this.spark.internal.lyra.space.leave(space, options)
        .catch((err) => {
          console.error('DeviceManager#unpair: failed to remove device from Lyra', err);
          return Promise.reject(err);
        });
    }
    return Promise.reject(new Error('DeviceManager#unpair: no device to unpair'));
  },

  /**
  * binds the space to the paired device (if supported)
  * similar to space.bindConversation()
  * @param {string} convoId
  * @returns {Promise<deviceInfo>}
  */
  bindSpace(convoId) {
    if (this._pairedDevice) {
      // fetch the conversation if just the convoId is provided
      // TODO: no need to fetch the conversation if already provided
      const url = `${this.spark.internal.device.services.conversationServiceUrl}/conversations/${convoId}`;
      return this.spark.internal.conversation.get({url}, {
        url,
        includeUxTimers: true,
        ackFilter: 'noack',
        includeParticipants: false,
        lastViewableActivityOnly: true,
        participantsLimit: 0
      })
        .then((conversation) => {
          // first check the validity of device and conversation
          const space = {url: `/spaces/${this._pairedDevice.identity.id}`, id: this._pairedDevice.identity.id};
          this._boundSpace = conversation;
          return this.spark.internal.lyra.space.bindConversation(space, conversation);
        })
        .catch((err) => {
          console.error('DeviceManager#bindSpace: failed to bind device to Space');
          return Promise.reject(err);
        });
    }
    console.error('DeviceManager#bindSpace: No device paired currently');
    return Promise.reject(new Error('DeviceManager#bindSpace: No device paired currently'));
  },

  /**
  * unbinds the space to the paired device (if supported)
  * similar to space.unbindConversation()
  * @returns {Promise<deviceInfo>}
  */
  unbindSpace() {
    if (!this._pairedDevice || !this._boundSpace) {
      console.error('DeviceManager#unbindSpace: No space currently bound to the device');
      return Promise.reject(new Error('DeviceManager#unbindSpace: No space currently bound to the device'));
    }
    const space = {url: `/spaces/${this._pairedDevice.identity.id}`, id: this._pairedDevice.identity.id};
    return this.spark.internal.lyra.space.unbindConversation(space, this._boundSpace)
      .then((res) => {
        this._boundSpace = null;
        return Promise.resolve(res);
      })
      .catch((err) => {
        console.error('DeviceManager#unbindSpace: failed to unbind Space to device');
        return Promise.reject(err);
      });
  },

  /**
  * Gets the audio state of the paired device
  * similar to device.getAudioState()
  * @returns {Promise<audioState>}
  */
  getAudioState() {
    if (!this._pairedDevice) {
      console.error('DeviceManager#getAudioState: Currently no device is paired');
      return Promise.reject(new Error('DeviceManager#getAudioState: Currently no device is paired'));
    }
    return this.spark.internal.lyra.device.getAudioState(this._pairedDevice);
  },

  /**
  * Updates audio state of the paired device, should be called every 10 minutes
  * or when mic or volume state is changed
  * similar to device.putAudioState()
  * @param {object} space
  * @param {object} audioState
  * @returns {Promise<audioState>}
  */
  putAudioState(space, audioState = {}) {
    return this.spark.internal.lyra.device.putAudioState(space, audioState);
  },

  /**
  * Mutes paired device
  * similar to device.mute()
  * @returns {Promise<audioState>}
  */
  mute() {
    if (!this._pairedDevice) {
      console.error('DeviceManager#mute: Currently no device is paired');
      return Promise.reject(new Error('DeviceManager#mute: Currently no device is paired'));
    }
    return this.spark.internal.lyra.device.mute(this._pairedDevice);
  },

  /**
  * Unmutes paired device
  * similar to device.unmute()
  * @returns {Promise<audioState>}
  */
  unmute() {
    if (!this._pairedDevice) {
      console.error('DeviceManager#unmute: Currently no device is paired');
      return Promise.reject(new Error('DeviceManager#unmute: Currently no device is paired'));
    }
    return this.spark.internal.lyra.device.unmute(this._pairedDevice);
  },

  /**
  * Increases paired device's volume
  * similar to device.increaseVolume()
  * @returns {Promise<audioState>}
  */
  increaseVolume() {
    if (!this._pairedDevice) {
      console.error('DeviceManager#increaseVolume: Currently no device is paired');
      return Promise.reject(new Error('DeviceManager#increaseVolume: Currently no device is paired'));
    }
    return this.spark.internal.lyra.device.increaseVolume(this._pairedDevice);
  },

  /**
  * Decreases paired device's volume
  * similar to device.decreaseVolume()
  * @returns {Promise<audioState>}
  */
  decreaseVolume() {
    if (!this._pairedDevice) {
      console.error('DeviceManager#decreaseVolume: Currently no device is paired');
      return Promise.reject(new Error('DeviceManager#decreaseVolume: Currently no device is paired'));
    }
    return this.spark.internal.lyra.device.decreaseVolume(this._pairedDevice);
  },

  /**
  * Sets paired device's volume but should use increase and decrease api instead
  * similar to device.setVolume()
  * @param {number} level
  * @returns {Promise<audioState>}
  */
  setVolume(level = 0) {
    if (!this._pairedDevice) {
      console.error('DeviceManager#setVolume: Currently no device is paired');
      return Promise.reject(new Error('DeviceManager#setVolume: Currently no device is paired'));
    }
    return this.spark.internal.lyra.device.setVolume(this._pairedDevice, level);
  },

  /**
  * Utility function to return the unencrypted device name
  * @param {object} device
  * @returns {deviceName}
  */
  _decryptDeviceName(device) {
    if (device.metadata
      && device.metadata.encryptedUserAssignedName
      && device.metadata.encryptionKeyUrl) {
      return this.spark.internal.encryption.decryptText(
        device.metadata.encryptionKeyUrl, device.metadata.encryptedUserAssignedName
      )
        .then((decryptedDeviceName) => {
          // set userAssignedName as the decypted value, unset encryptedUserAssignedName since it's not needed
          device.metadata.encryptedUserAssignedName = undefined;
          device.metadata.userAssignedName = decryptedDeviceName;
        })
        .catch((err) => {
          // unset encryptedUserAssignedName if failed to decrypt
          device.metadata.encryptedUserAssignedName = undefined;
          console.error('DeviceManager#_decryptDeviceName: failed to decrypt device name', err);
        });
    }
    return Promise.resolve(true);
  }

});

export default DeviceManager;
