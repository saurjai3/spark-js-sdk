/**!
 *
 * Copyright (c) 2015-2016 Cisco Systems, Inc. See LICENSE file.
 */

 /* eslint camelcase: [0] */

import '@ciscospark/plugin-calendar';
import CiscoSpark from '@ciscospark/spark-core';
import {assert} from '@ciscospark/test-helper-chai';
import retry from '@ciscospark/test-helper-retry';
import testUsers from '@ciscospark/test-helper-test-users';
import uuid from 'uuid';
import {merge} from 'lodash';


/**
 * produces a mock meeting object
 * @param {Object} params
 * @returns {Meeting}
 */
function makeMockMeetingPayload(params) {
  params = params || {};
  return merge({
    changeType: params.changeType,
    userId: params.organizer.emailAddress,
    userUUID: params.organizer.id,
    emailAddress: params.organizer.emailAddress,
    itemId: `ItemId-${params.meetingId}`,
    meeting: {
      body: params.body,
      callUri: `https://locus-example.com/locus/api/v1/loci/${params.locusId}`,
      encryptionV2: true,
      endDate: params.end,
      featureTogglesMap: [
        {
          calsvc_calendar_view: true
        }
      ],
      hasAttachments: params.hasAttachments,
      iCalUid: params.meetingId,
      isRecurring: params.isRecurring,
      isReminderSet: params.isReminderSet,
      itemId: `ItemId-${params.meetingId}`,
      location: params.location,
      mailboxAttendeesInMeeting: [
        params.participants.participant1.emailAddress,
        params.participants.participant2.emailAddress
      ],
      mailboxInviteesInMeeting: [
        {
          id: params.participants.participant1.id,
          invitee: params.participants.participant1.emailAddress,
          type: `PERSON`,
          responseType: `NO_RESPONSE`,
          participantType: `OPTIONAL`
        },
        {
          id: params.participants.participant2.id,
          invitee: params.participants.participant2.emailAddress,
          type: `PERSON`,
          responseType: `UNKNOWN_RESPONSE`,
          participantType: `REQUIRED`
        }
      ],
      meetingIdentifier: {
        id: `MeetingId-${params.meetingId}`
      },
      meetingTime: params.start,
      organizer: params.organizer.emailAddress,
      startDate: params.start,
      subject: params.title
    },
    meetingIdentifier: {
      id: `MeetingId-${params.meetingId}`
    }
  }, params);
}

function postToWhistler(spark, payload) {
  return retry(() => spark.request({
    method: `POST`,
    service: `whistler`,
    resource: `calendarNotification`,
    body: payload,
    qs: {
      isinteg: typeof process.env.WDM_SERVICE_URL !== `undefined` && process.env.WDM_SERVICE_URL.indexOf(`wdm-a.wbx2.com`) < 0
    }
  })
    .then((res) => {
      // Test response is using our parameters
      const createdMeeting = res.body;
      assert.isDefined(createdMeeting);
      assert.equal(createdMeeting.meeting.meetingIdentifier.id, payload.meetingIdentifier.id);
      assert.equal(createdMeeting.userUUID, payload.userUUID);
      assert.equal(createdMeeting.meeting.startDate, payload.meeting.startDate);
      assert.equal(createdMeeting.meeting.endDate, payload.meeting.endDate);
      return res;
    }));
}

describe(`plugin-calendar`, () => {
  describe(`Calendar`, () => {
    describe(`#list()`, function() {
      this.timeout(retry.timeout(20000));
      let creator, mccoy, spark, spock;

      before(`create test users`, () => testUsers.create({
        count: 3,
        config: {
          entitlements: [
            `spark`,
            `squaredCallInitiation`,
            `squaredInviter`,
            `squaredRoomModeration`,
            `webExSquared`,
            `squaredFusionCal`
          ]
        }
      })
        .then((users) => {
          [creator, spock, mccoy] = users;

          spark = new CiscoSpark({
            credentials: {
              authorization: creator.token
            },
            config: {
              device: {
                preDiscoveryServices: {
                  whistlerServiceUrl: process.env.WHISTLER_API_SERVICE_URL || `http://internal-testing-services.wbx2.com:8084/api/v1`
                }
              }
            }
          });
        })
      );

      before(`register to wdm, set features, and connect to mercury`, () => spark.device.register()
        .then(() => spark.feature.setFeature(`developer`, `calsvc_calendar_view`, true))
        .then(() => spark.mercury.connect())
      );

      after(() => spark && spark.mercury.disconnect());

      it(`retrieves the meeting list for the default date range`, () => {
        const hour = 1000 * 60 * 60;
        const startInterval = new Date(new Date().getTime() + hour * 2).toISOString();
        const endInterval = new Date(new Date(startInterval).getTime() + hour).toISOString();
        const meetingID = uuid.v4();
        const locusID = uuid.v4();

        const meetingParams = {
          changeType: `CREATE`,
          meetingId: meetingID,
          start: startInterval,
          end: endInterval,
          title: `test-plugin-calendar-meeting-${meetingID}`,
          locusId: locusID,
          hasAttachments: false,
          isRecurring: false,
          isReminderSet: false,
          organizer: creator,
          participants: {
            participant1: mccoy,
            participant2: spock
          },
          location: `@spark`,
          body: `Test Agenda`
        };

        return postToWhistler(spark, makeMockMeetingPayload(meetingParams))
          .then((res) => {
            const createdMeeting = res.body;
            return spark.calendar.list()
              .then((meetings) => {
                const testMeeting = meetings.find((meeting) => meeting.seriesId === createdMeeting.meeting.icalUid);
                assert.isDefined(testMeeting);
                assert.equal(createdMeeting.userUUID, testMeeting.organizer);
                assert.equal(createdMeeting.meeting.startDate, testMeeting.start);
                assert.equal(Math.round((new Date(createdMeeting.meeting.endDate).getTime() - new Date(createdMeeting.meeting.startDate).getTime()) / 60000), testMeeting.durationMinutes);

                // Validate decryption of subject, location and agenda
                assert.isDefined(testMeeting.encryptedSubject);
                assert.equal(meetingParams.title, testMeeting.encryptedSubject);
                assert.isDefined(testMeeting.encryptedLocation);
                assert.equal(meetingParams.location, testMeeting.encryptedLocation);
                assert.isDefined(testMeeting.encryptedNotes);
                assert.equal(meetingParams.body, testMeeting.encryptedNotes);
              });
          });
      });

      it(`receives a mercury event for a new meeting`, () => {
        const hour = 1000 * 60 * 60;
        const startInterval = new Date(new Date().getTime() + hour * 2).toISOString();
        const endInterval = new Date(new Date(startInterval).getTime() + hour).toISOString();
        const meetingID = uuid.v4();
        const locusID = uuid.v4();

        const meetingParams = {
          changeType: `CREATE`,
          meetingId: meetingID,
          start: startInterval,
          end: endInterval,
          title: `test-plugin-calendar-meeting-${meetingID}`,
          locusId: locusID,
          hasAttachments: false,
          isRecurring: false,
          isReminderSet: false,
          organizer: creator,
          participants: {
            participant1: mccoy,
            participant2: spock
          },
          location: `@spark`,
          body: `Test Agenda`
        };

        const mercuryPromise = new Promise((resolve) => {
          spark.mercury.on(`event:calendar.meeting.create`, (event) => {
            resolve(event.data.calendarMeetingExternal);
          });
        });

        return postToWhistler(spark, makeMockMeetingPayload(meetingParams))
          .then((res) => {
            const createdMeeting = res.body;
            return assert.isFulfilled(mercuryPromise)
              .then((calendarMeetingExternal) => {
                assert.equal(createdMeeting.meeting.icalUid, calendarMeetingExternal.seriesId);
                assert.equal(createdMeeting.userUUID, calendarMeetingExternal.organizer);
                assert.equal(createdMeeting.meeting.startDate, calendarMeetingExternal.start);
                assert.equal(Math.round((new Date(createdMeeting.meeting.endDate).getTime() - new Date(createdMeeting.meeting.startDate).getTime()) / 60000), calendarMeetingExternal.durationMinutes);

                // Validate decryption of subject, location and agenda
                assert.isDefined(calendarMeetingExternal.encryptedSubject);
                assert.equal(meetingParams.title, calendarMeetingExternal.encryptedSubject);
                assert.isDefined(calendarMeetingExternal.encryptedLocation);
                assert.equal(meetingParams.location, calendarMeetingExternal.encryptedLocation);
                assert.isDefined(calendarMeetingExternal.encryptedNotes);
                assert.equal(meetingParams.body, calendarMeetingExternal.encryptedNotes);
              });
          });
      });
    });
  });
});
