/**!
 *
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/plugin-encryption';

import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import CiscoSpark from '@ciscospark/spark-core';
import testUsers from '@ciscospark/test-helper-test-users';
import uuid from 'uuid';

describe(`Encryption`, function() {
  this.timeout(30000);
  describe(`KMS`, () => {
    let mccoy, spark, spock;

    before(`create test user`, () => testUsers.create({count: 2})
      .then((users) => {
        spock = users[0];
        spark = new CiscoSpark({
          credentials: {
            authorization: spock.token
          }
        });
        assert.isTrue(spark.canAuthorize);

        mccoy = users[1];
        mccoy.spark = new CiscoSpark({
          credentials: {
            authorization: mccoy.token
          }
        });

        assert.isTrue(mccoy.spark.canAuthorize);
        return mccoy.spark.device.register();
      }));

    after(() => spark && spark.mercury.disconnect());

    describe(`#createResource()`, () => {
      it(`creates a kms resource object`, () => spark.encryption.kms.createUnboundKeys({count: 1})
        .then(([key]) => spark.encryption.kms.createResource({
          userIds: [spark.device.userId],
          key
        })
          .then((kro) => {
            assert.property(kro, `uri`);
            assert.property(kro, `keyUris`);
            assert.lengthOf(kro.keyUris, 1);
            assert.include(kro.keyUris, key.uri);
            assert.property(kro, `authorizationUris`);
            assert.lengthOf(kro.authorizationUris, 1);
          })));
    });

    describe(`#addAuthorization()`, () => {
      let boundedKeyUri, kro, otherKro;
      before(`create a resource`, () => spark.encryption.kms.createUnboundKeys({count: 1})
        .then(([key]) => spark.encryption.kms.createResource({
          key
        }))
        .then((k) => {
          kro = k;
          boundedKeyUri = kro.keyUris[0];
          assert.lengthOf(kro.authorizationUris, 1);
        }));

      it(`authorizes a user to a key`, () => spark.encryption.kms.addAuthorization({
        userIds: [mccoy.spark.device.userId],
        kroUri: kro.uri
      })
        .then(([auth]) => {
          assert.equal(auth.resourceUri, kro.uri);
          assert.equal(auth.authId, mccoy.spark.device.userId);
          return assert.isFulfilled(mccoy.spark.encryption.kms.fetchKey({uri: boundedKeyUri}));
        }));

      it(`authorizes a resource to a key`, () => spark.encryption.kms.createUnboundKeys({count: 1})
        .then(([key]) => spark.encryption.kms.createResource({key}))
        .then((k) => {
          otherKro = k;
          return spark.encryption.kms.addAuthorization({
            authIds: [otherKro.uri],
            kro
          });
        })
        .then(([auth]) => {
          assert.equal(auth.resourceUri, kro.uri);
          assert.equal(auth.authId, otherKro.uri);
        }));
    });

    describe(`#removeAuthorization()`, () => {
      let boundedKeyUri, kro, otherKro;
      before(`create resource`, () => spark.encryption.kms.createUnboundKeys({count: 1})
        .then(([key]) => spark.encryption.kms.createResource({
          key
        }))
        .then((k) => {
          kro = k;
          boundedKeyUri = kro.keyUris[0];
          assert.lengthOf(kro.authorizationUris, 1);
        }));

      before(`create another resource`, () => spark.encryption.kms.createUnboundKeys({count: 1})
        .then(([key]) => spark.encryption.kms.createResource({
          key
        }))
        .then((k) => {
          otherKro = k;
        }));

      before(`add auths to resource`, () => spark.encryption.kms.addAuthorization({
        authIds: [otherKro.uri, mccoy.spark.device.userId],
        kro
      })
        .then(([kroAuth, userAuth]) => {
          assert.equal(kroAuth.authId, otherKro.uri);
          assert.equal(userAuth.authId, mccoy.spark.device.userId);
        }));

      it(`deauthorizes a user from a key`, () => spark.encryption.kms.removeAuthorization({
        userId: mccoy.spark.device.userId,
        kroUri: kro.uri
      })
        .then(([auth]) => {
          assert.equal(auth.resourceUri, kro.uri);
          assert.equal(auth.authId, mccoy.spark.device.userId);
          return assert.isRejected(mccoy.spark.encryption.kms.fetchKey({uri: boundedKeyUri}));
        }));

      it(`deauthorizes a resource from a key`, () => spark.encryption.kms.removeAuthorization({
        authId: otherKro.uri,
        kro
      })
        .then(([auth]) => {
          assert.equal(auth.resourceUri, kro.uri);
          assert.equal(auth.authId, otherKro.uri);
        }));
    });

    describe(`#bindKey()`, () => {
      let key2, kro;
      it(`binds a resource to a key`, () => spark.encryption.kms.createUnboundKeys({count: 2})
        .then((keys) => {
          key2 = keys[1];
          return spark.encryption.kms.createResource({
            userIds: [spark.device.userId],
            key: keys[0]
          });
        })
        .then((k) => {
          kro = k;
          return spark.encryption.kms.bindKey({kro, key: key2});
        })
        .then((key) => {
          assert.equal(key.uri, key2.uri);
          assert.property(key, `bindDate`);
          assert.property(key, `resourceUri`);
          assert.equal(key.resourceUri, kro.uri);
        }));
    });

    describe(`#createUnboundKeys()`, () => {
      it(`requests unbound keys from the KMS`, () => spark.encryption.kms.createUnboundKeys({count: 2})
        .then((keys) => {
          assert.lengthOf(keys, 2);

          const [key1, key2] = keys;

          assert.property(key1, `uri`);
          assert.property(key1, `jwk`);
          assert.property(key2, `uri`);
          assert.property(key2, `jwk`);
        }));
    });

    describe(`#fetchKey()`, () => {
      let key;
      it(`retrieves a specific key`, () => spark.encryption.kms.createUnboundKeys({count: 1})
        .then(([k]) => {
          key = k;
          return spark.encryption.kms.fetchKey({uri: key.uri});
        })
        .then((key2) => {
          assert.property(key2, `uri`);
          assert.property(key2, `jwk`);
          assert.notEqual(key2, key);
          assert.equal(key2.uri, key.uri);
        }));
    });

    describe(`#ping()`, () => {
      it(`sends a ping to the kms`, () => assert.isFulfilled(spark.encryption.kms.ping())
        .then((res) => {
          assert.property(res, `status`);
          assert.equal(res.status, 200);
          assert.property(res, `requestId`);
        }));
    });

    describe(`when ecdhe negotiation times out`, () => {
      let originalKmsTimeout, spark2, spy;
      before(`create test user`, () => testUsers.create({count: 1})
        .then(([u]) => {
          spark2 = new CiscoSpark({
            credentials: {
              authorization: u.token
            }
          });
          assert.isTrue(spark.canAuthorize);
        }));

      after(() => spark2 && spark2.mercury.disconnect());

      beforeEach(`alter config`, () => {
        originalKmsTimeout = spark2.config.encryption.kmsInitialTimeout;
        spark2.config.encryption.kmsInitialTimeout = 100;
        spy = sinon.spy(spark2.encryption.kms, `prepareRequest`);
      });

      afterEach(() => {
        spark2.config.encryption.kmsInitialTimeout = originalKmsTimeout;
      });

      afterEach(() => spy.restore());

      it(`handles late ecdhe responses`, () => assert.isFulfilled(spark2.encryption.kms.ping())
        .then(() => {
          // callCount should be at least 3:
          // 1 for the initial ping message
          // 1 when the ecdh key gets renegotiated
          // 1 when the pings gets sent again
          assert.isAbove(spy.callCount, 2, `If this test fails, we've made previously-assumed-to-be-impossible performance gains in cloudapps; please update this test accordingly.`);
        }));
    });

    describe(`when the kms is in another org`, () => {
      let fedSpark;

      before(`create test user in other org`, () => testUsers.create({
        count: 1,
        config: {
          email: `spark-js-sdk--kms-fed--${uuid.v4()}@wx2.example.com`,
          entitlements: [`webExSquared`],
          orgId: `kmsFederation`
        }
      })
        .then((users) => {
          const fedUser = users[0];
          assert.equal(fedUser.orgId, `75dcf6c2-247d-4e3d-a32c-ff3ee28398eb`);
          assert.notEqual(fedUser.orgId, spock.orgId);

          fedSpark = new CiscoSpark({
            credentials: {
              authorization: fedUser.token
            }
          });
          assert.isTrue(fedSpark.canAuthorize);
        }));

      before(`connect federated user to mercury`, () => fedSpark.mercury.connect());

      after(() => fedSpark && fedSpark.mercury.disconnect());

      it(`responds to pings`, () => assert.isFulfilled(fedSpark.encryption.kms.ping())
        .then((res) => {
          assert.property(res, `status`);
          assert.equal(res.status, 200);
          assert.property(res, `requestId`);
        }));

      let key;
      it(`lets federated users retrieve keys from the main org`, () => spark.encryption.kms.createUnboundKeys({count: 1})
        .then(([k]) => {
          key = k;
          return spark.encryption.kms.createResource({
            userIds: [
              spark.device.userId,
              fedSpark.device.userId
            ],
            key
          });
        })
        .then(() => fedSpark.encryption.kms.fetchKey({uri: key.uri}))
        .then((fedKey) => assert.equal(fedKey.keyUri, key.keyUri)));

      let fedKey;
      it(`lets non-federated users retrieve keys from the federated org`, () => fedSpark.encryption.kms.createUnboundKeys({count: 1})
        .then(([k]) => {
          fedKey = k;
          return fedSpark.encryption.kms.createResource({
            userIds: [
              fedSpark.device.userId,
              spark.device.userId
            ],
            key: fedKey
          });
        })
        .then(() => spark.encryption.kms.fetchKey({uri: fedKey.uri}))
        .then((key) => assert.equal(key.keyUri, fedKey.keyUri)));
    });
  });
});
